{"plan": "We state that every element except for the elements with the smallest value can be deleted.\nProof: denote \nMN\n as the minimum element (s) of the array \na\n, in each operation pick \nMN\n and some other element, say \nX\n, which is bigger than \nMN\n, since \nAVG = \\frac{X + MN}{2} < X\n, then \nX\n will be deleted.\nDoing this for every \nX > MN\n will result in the deletion of every element except for the elements with the smallest value. So the answer to the problem is \nn - cntMN\n, where \ncntMN\n is the number of times \nMN\n appeared in \na\n.\ncomplexity: \n\\mathcal{O}(n)", "id": "1529A", "url": "https://codeforces.com/contest/1529/problem/A"}
{"plan": "Let's consider that \nl_1\n, \nl_2\n, and \nl_3\n are sorted working segments.\nIf \nl_1\n is not equal to \n1\n then we can decrease \nl_1\n by \n1\n and increase \nl_3\n by \n1\n. So we'll increase the answer.\nWe've got that \nl_1 = 1\n and we have to work just with \nl_2\n and \nl_3\n.\nNow, our problem can be rewritten as:\nl_2 + l_3 = n - 4\n, maximize \nmin(l_2 - 1, l_3 - l_2)\n.\nAnd as we know that \nl_3 = n - 4 - l_2\n, just:\nmaximize \nmin(l_2 - 1, n - 4 - 2 \\cdot l_2)\n.\nIf we increase both values under the minimum scope by one, solutions don't change:\nmaximize \nmin(l_2, (n - 3) - 2 \\cdot l_2)\n.\nIf we choose \nl_2 = \\left\\lfloor\\frac{n-3}{3}\\right\\rfloor\n, then \nmin(l_2, (n - 3) - 2 \\cdot l_2) = \\left\\lfloor\\frac{n-3}{3}\\right\\rfloor\n.\nIf the answer is greater, then \nl_2 > \\frac{n - 3}{3}\n and \n(n - 3) - 2 \\cdot l_2 > \\frac{n - 3}{3}\n, and it means that \n2 \\cdot (l_2) + ((n - 3) - 2 \\cdot l_2) > n - 3\n but \n2 \\cdot (l_2) + ((n - 3) - 2 \\cdot l_2) = n - 3\n.\nThe only thing is left to do is to calculate final answer. And it is \n\\left\\lfloor\\frac{n-3}{3}\\right\\rfloor - 1\n or just \n\\left\\lfloor\\frac{n}{3}\\right\\rfloor - 2\n.\nIt was a mathematician way of solving. As it's pretty obvious that \nl_2\n is approximately \n\\frac{n}{3}\n, you could check \nl_2 = \\frac{n}{3} \\pm 5\n and choose the best among them.", "id": "1735A", "url": "https://codeforces.com/contest/1735/problem/A"}
{"plan": "Solution 1\nFor all \ni \\ge 2\n, \na_i\n is the multiple of \na_1\n is equivalent to the YES answer.\nProof of necessity\na_2\n must be the multiple of \na_1\n. Otherwise \na_2\n cannot become zero.\nIn the whole process, \na_2\n is always the multiple of \na_1\n. So \na_3\n must be the multiple of \na_1\n. Otherwise \na_3\n cannot become zero.\nIn the whole process, \na_3\n is always the multiple of \na_1\n. So \na_4\n must be the multiple of \na_1\n. Otherwise \na_4\n cannot become zero.\n...\nProof of sufficiency\nFor all \ni \\ge 2\n, \na_i\n is the multiple of \na_1\n. So we can perform operations to make \na=[a_1,a_1,a_1,\\cdots]\n and then make \na=[a_1,0,0,\\cdots]\n.\nSolution 2\nConsider everything in the reverse order.\nYou are given an array \nb\n consisting of \nn\n positive integers, where \nb=[b_1,0,0,\\cdots,0]\n (\nb_1\n and \nn-1\n zeros).\nYou are given an array \na\n consisting of \nn\n positive integers. It is guaranteed that \na_1=b_1\n.\nYou are allowed to perform this operation any number of times (possibly, zero):\n \n Choose an index \ni\n (\n2\\le i \\le n\n), and change \nb_i\n to \nb_i+b_{i-1}\n. \nIs it possible to change \nb\n to \na\n?\nCheck if \na_i\n is the multiple of \na_1\n.", "id": "1708A", "url": "https://codeforces.com/contest/1708/problem/A"}
{"plan": "We can add or subtract \n10\n until the difference between \na\n and \nb\n becomes less than \n10\n. And if it is not \n0\n after all such moves, we need one additional move.\nLet \nd = |a - b|\n is the absolute difference between \na\n and \nb\n. The final answer is \n\\left\\lfloor\\frac{d}{10}\\right\\rfloor\n plus one if \nd \\mod 10 > 0\n. This formula can be represented as \nd\n divided by \n10\n rounded up, in other words \n\\left\\lfloor\\frac{d+9}{10}\\right\\rfloor\n.", "id": "1409A", "url": "https://codeforces.com/contest/1409/problem/A"}
{"plan": "Obviously, answer does not exceed \nmax_{1} + max_{2} - min_{1} - min_{2}\n, where \nmax_{1}, max_{2}\n are two maximum values in the array, and \nmin_{1}, min_{2}\n are two minimum values. Let's find a segment, such as this is true. For that we will look at all positions containing \nmax_{1}\n or \nmax_{2}\n (\nS_{1}\n) and all positions containing \nmin_{1}\n or \nmin_{2}\n (\nS_2\n). After that we choose a pair \nl \\in S_1\n, \nr \\in S_2\n, such as \nabs(r - l)\n is minimum possible. Complexity: \nO(n\\log n)", "id": "1720B", "url": "https://codeforces.com/contest/1720/problem/B"}
{"plan": "There are many ways to solve this problem. Basically, we need to check two conditions.\nThe first one is the condition on the number of characters: \nn \\bmod 3 \\ne 2\n, since after the first key press, we get the remainder \n1\n modulo \n3\n, after the second key press, we get the remainder \n0\n modulo \n3\n, then \n1\n again, then \n0\n — and so on, and we cannot get the remainder \n2\n.\nThen we need to check that, in each pair of characters which appeared from the same key press, these characters are the same — that is, \ns_2 = s_3\n, \ns_5 = s_6\n, \ns_8 = s_9\n, and so on.", "id": "1765B", "url": "https://codeforces.com/contest/1765/problem/B"}
{"plan": "If any element is not a perfect square, the answer is yes. Otherwise, the answer is no, because \na^2*b^2*...=(a*b*...)^2\n.", "id": "1514A", "url": "https://codeforces.com/contest/1514/problem/A"}
{"plan": "If \n\\max(a) - \\min(a)\n is strictly greater than \n1\n, you can apply the operation on the max and the min respectively, which brings them both closer to each other. In other words, it either decreases \n\\max(a) - \\min(a)\n or leaves it the same. This implies that the answer is always \n\\leq 1\n. Now what remains is determining whether the answer is \n0\n or \n1\n. The answer can only be \n0\n if the sum of the array is divisible by \nn\n, as the sum of the array can't change after an operation, and if it's not divisible by \nn\n you can't make every element equal. This means that the answer is \n0\n if the sum is divisible by \nn\n, and \n1\n otherwise.", "id": "1615A", "url": "https://codeforces.com/contest/1615/problem/A"}
{"plan": "Observe that there are exactly two strings of length \nn-1\n (one prefix and one suffix). We will call them \nx\n and \ny\n. Then, \ns\n is a palindrome if and only if \n\\text{rev}(x)=y\n, where \n\\text{rev}(x)\n is the reversal of string \nx\n.\nSo, to solve the problem it is enough to find the two strings of length \nn-1\n and check if one of them is equal to the reversal of the other. This solution also works for any length greater or equal to \n\\lfloor \\frac{n}{2} \\rfloor\n.\nIntended complexity: \n\\mathcal{O}(n^2)\n per test case. (reading the input)", "id": "1794A", "url": "https://codeforces.com/contest/1794/problem/A"}
{"plan": "Let \nm_1 = \\max(a_1, a_2, ..., a_n, b_1, b_2, ..., b_n)\n. The answer will always be \nm_1 \\cdot m_2\n where \nm_2\n is the maximum of the array that does not contain \nm_1\n.\nSince \nm_1\n is fixed, the problem can be reduced to minimize \nm_2\n, that is, minimize the maximum of the array that does not contain the global maximum.\nWLOG assume that the global maximum will be in the array \nb\n, we can swap elements at each index \nx\n such that \na_x > b_x\n, ending with \na_i \\leq b_i\n for all \ni\n. It can be shown that the maximum of array \na\n is minimized in this way.\nTime complexity: \nO(n)\n \nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\n\n\nusing\n \nnamespace\n std\n;\n\n \n\nint\n calc_max\n(\nvector\n<int>\n a\n){\n\n    \nint\n res \n=\n \n0\n;\n\n    \nfor\n(\n \nauto\n i \n:\n a \n)\n\n        res \n=\n max\n(\n res \n,\n i \n);\n\n    \nreturn\n res\n;\n\n\n}\n\n \n\nint\n main\n(){\n\n    \nint\n tc\n;\n\n    cin \n>>\n tc\n;\n\n    \nwhile\n(\n tc\n--\n \n){\n\n        \nint\n n\n;\n\n        cin \n>>\n n\n;\n\n \n        vector\n<int>\n a\n(\nn\n),\n b\n(\nn\n);\n\n        \nfor\n(\n \nauto\n \n&\ni \n:\n a \n)\n\n            cin \n>>\n i\n;\n\n        \nfor\n(\n \nauto\n \n&\ni \n:\n b \n)\n\n            cin \n>>\n i\n;\n\n \n        \nfor\n(\nint\n i\n=\n0\n;\n i\n<\nn\n;\n i\n++)\n\n            \nif\n(\n a\n[\ni\n]\n \n>\n b\n[\ni\n]\n \n)\n\n                swap\n(\n a\n[\ni\n]\n \n,\n b\n[\ni\n]\n \n);\n\n \n        cout \n<<\n calc_max\n(\na\n)\n \n*\n calc_max\n(\nb\n)\n \n<<\n \n'\\n'\n;\n\n    \n}\n\n\n}", "id": "1631A", "url": "https://codeforces.com/contest/1631/problem/A"}
{"plan": "We can't take the smallest character in both strings when we've already took \nk\n elements from the string we chose. Denote \nA\n as the number of characters we've took from string \na\n in the last few consecutive moves and denote \nB\n the same for \nb\n. If \nA=k\n, then we have to take the smallest character in string \nb\n instead of possibly \na\n. If \nB=k\n, then we have to take the smallest character in string \na\n instead of possibly \nb\n.\nRemember to reset \nA\n to \n0\n when you take a character from \nb\n. Similarly, reset \nB\n to \n0\n when you take a character from \na\n.", "id": "1689A", "url": "https://codeforces.com/contest/1689/problem/A"}
{"plan": "We'll search for positive integers not larger than \nn\n, and add their squares or cubes to the set if they don't exceed \nn\n. If \nn = 10^9\n, the maximum number Polycarp will like is \n31622^2 = 999950884\n, so the running time will be within the time limit.\nThe answer to the problem is the length of the resulting set.", "id": "1619B", "url": "https://codeforces.com/contest/1619/problem/B"}
{"plan": "Let \nd\n be the largest decimal digit of \nn\n.\nNote that we need at least \nd\n binary decimals to represent \nn\n as a sum. Indeed, if we only use \nk < d\n binary decimals, no digit of the sum will ever exceed \nk\n. However, we need at least one digit equal to \nd\n.\nAt the same time, it is easy to construct an answer with exactly \nd\n terms. Start with all terms equal to \n0\n, and consider each digit separately. Let the \ni\n-th digit of \nn\n be \na_i\n. Pick any \na_i\n terms out of the \nd\n terms we have, and add \n1\n to their \ni\n-th digits.\nTherefore, the answer is \nd\n.", "id": "1530A", "url": "https://codeforces.com/contest/1530/problem/A"}
{"plan": "It is easy to see that if there are no water locations, the answer is \n0\n. Otherwise, we should jump from the last accessible from the start land location to the first land location from which the finish is accessible. In order to find these locations, one can use two consecutive while loops, one increasing \nl\n from \n1\n until \na_{l + 1} = 0\n, and the other one decreasing \nr\n from \nn\n until \na_{r - 1} = 0\n. After the loops finish, we know that we should jump from the \nl\n-th location to the \nr\n-th at the cost of \nr - l\n.", "id": "1649A", "url": "https://codeforces.com/contest/1649/problem/A"}
{"plan": "Let's process each character of the string from left to right and store the number of unanswered questions \ncnt\n. Initially this value equals to zero. Consider the \ni\n-th character of the string. If it equals to \"\nQ\n\", increase \ncnt\n by one. If it equals to \"\nA\n\", decrease \ncnt\n by one. If \ncnt\n has become negative, it means that some of the questions was answered several times. In this case let's assign zero to \ncnt\n.\nIf \ncnt\n will be equal to zero after processing all string, then all questions were answered, and the answer is \"\nYes\n\". Otherwise, the answer is \"\nNo\n\".\nTime complexity: \n\\mathcal{O}(n)\n for each test case.", "id": "1754A", "url": "https://codeforces.com/contest/1754/problem/A"}
{"plan": "Let's analyze which values can the function \ng(x)\n have. It can be proven that the value of \ng(x)\n is equal to \n10^k\n, where \nk\n is the number of zero-digits at the end of the number \nx\n, because \nf(f(x))\n is the same number as \nx\n except for the fact that it doesn't have any trailing zeroes.\nOkay, now let's analyze when we reach the new value of \ng(x)\n. \n1\n is the first value of \nx\n such that \ng(x) = 1\n, \n10\n is the first value of \nx\n such that \ng(x) = 10\n, \n100\n is the first value of \nx\n such that \ng(x) = 100\n, and so on. We have to calculate the maximum number that has the form \n10^k\n and is not greater than \nn\n, and the answer is exactly \nk + 1\n.\nIt can be done with a mathematical solution, but the most simple way to do it is read \nn\n as a string instead, and calculate its length.", "id": "1455A", "url": "https://codeforces.com/contest/1455/problem/A"}
{"plan": "The problem is equivalent to finding the farthest cell from \n( x , y )\n. It is easy to see that, if they move optimally, \n( i , j )\n can reach \n( x , y )\n just by moving in an L shape, and this is equivalent to the Manhattan distance between the two points. The longest distance a prisoner will move on rows is \nmax( x - 1 , n - x )\n, and for the columns it is \n( y - 1 , m - y )\n. So answer is just \nmax( x - 1 , n - x ) + max( y - 1 , m - y )", "id": "1457A", "url": "https://codeforces.com/contest/1457/problem/A"}
{"plan": "Suppose we only have boxes on the \nOx+\n axis, then the optimal strategy is going in the following way: \n(0, 0), (x_{max}, 0), (0, 0)\n. There is no way to do in less than \n2 \\cdot |x_{max}|\n moves.\nWhat if we have boxes on two axis? Let's assume it is \nOy+\n, suppose we have a strategy to go in the following way: \n(0, 0), (x_{max}, 0),..., (0, y_{max}), (0, 0)\n. In this case it is optimal to fill the three dots with \n(0, 0)\n, which is just solving each axis independently.\nTherefore, the number of axis does not matters. For each axis that has at least one box, go from \n(0, 0)\n to the farthest one, then come back to \n(0, 0)\n.\nTime complexity: \nO(n)", "id": "1713A", "url": "https://codeforces.com/contest/1713/problem/A"}
{"plan": "To maximize the sum of \n\\textbf{MEX}\n on prefixes we will use a greedy algorithm. Firstly we put all unique elements in increasing order to get maximal \n\\textbf{MEX}\n on each prefix. It is easy to see that replacing any two elements after that makes both \n\\textbf{MEX}\n and sum of \n\\textbf{MEX}\n less.\nIn the end we put all elements that are not used in any order because \n\\textbf{MEX}\n will not change and will still be maximal.", "id": "1497A", "url": "https://codeforces.com/contest/1497/problem/A"}
{"plan": "It's easy to see that the FB-string repeats every \n8\n characters: after processing every \n15\n numbers, we will get the same remainders modulo \n3\n and \n5\n as \n15\n numbers ago, and when we process \n15\n consecutive numbers, we get \n8\n characters. So, \nf_{i+8} = f_i\n.\nThis means that if we want to find a substring no longer than \n10\n characters in the FB-string, we don't need to consider more than \n17\n first characters of the FB-string: the substring of length \n10\n starting with the \n8\n-th character ends with the \n17\n-th character, and we don't need to consider substrings starting on positions greater than \n8\n.\nSo, the solution is to generate at least \n17\n first characters of the FB-string, and then check if the substring occurs in the generated string using a standard function like \nfind\n.", "id": "1796A", "url": "https://codeforces.com/contest/1796/problem/A"}
{"plan": "We need to check if the sum of the first three digits is equal to the sum of the last three digits. This is doable by scanning the input as a string, then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation.", "id": "1676A", "url": "https://codeforces.com/contest/1676/problem/A"}
{"plan": "Here are two solutions.\nSolution 1.\n Iterate through the string character by character. If \ns_i=\\texttt{R}\n, then \nt_i=\\texttt{R}\n; otherwise, if \ns_i=\\texttt{G}\n or \n\\texttt{B}\n, then \nt_i=\\texttt{G}\n or \n\\texttt{B}\n. If the statement is false for any \ni\n, the answer is \nNO\n. Otherwise it is \nYES\n.\nSolution 2.\n Replace all \n\\texttt{B}\n with \n\\texttt{G}\n, since they are the same anyway. Then just check if the two strings are equal.\nIn either case the complexity is \n\\mathcal{O}(n)\n per testcase.", "id": "1722B", "url": "https://codeforces.com/contest/1722/problem/B"}
{"plan": "Notice that it never makes sense to move blocks between the towers such that neither of them is tower \n1\n as that can only decrease the heights. Moreover, it never makes sense to move blocks away from the tower \n1\n. Thus, all operations will be moving blocks from some towers to tower \n1\n.\nAt the start, which towers can move at least one block to tower \n1\n? Well, only such \ni\n that \na_i > a_1\n. What happens after you move a block? Tower \n1\n becomes higher, some tower becomes lower. Thus, the set of towers that can share a block can't become larger.\nLet's order the towers by the number of blocks in them. At the start, the towers that can share a block are at the end (on some suffix) in this order. After one move is made, the towers get reordered, and the suffix can only shrink.\nOk, but if that suffix shrinks, what's the first tower that will become too low? The leftmost one that was available before. So, regardless of what the move is, the first tower that might become unavailable is the leftmost available tower. Thus, let's attempt using it until it's not too late.\nThe algorithm then is the following. Find the lowest tower that can move the block to tower \n1\n, move a block, repeat. When there are no more towers higher than tower \n1\n, the process stops.\nHowever, the constraints don't allow us to do exactly that. We'll have to make at most \n10^9\n moves per testcase.\nOk, let's move the blocks in bulk every time. Since the lowest available tower will remain the lowest until you can't use it anymore, make all the moves from it at the same time. If the current number of blocks in tower \n1\n is \nx\n and the current number of blocks in that tower is \ny\n, \n\\lceil\\frac{y - x}{2}\\rceil\n blocks can be moved.\nYou can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height.\nOverall complexity: \nO(n \\log n)\n per testcase.", "id": "1767B", "url": "https://codeforces.com/contest/1767/problem/B"}
{"plan": "We describe two solutions. \nThe first focuses on maximal contiguous intervals of values. We notice that for each such interval \n[l, r]\n it can either remain unchanged or get increased to \n[l, r + 1]\n (other possibilities won't increase the number of different elements; thus, we don't need to consider them). From this observation, we conclude that the result is the number of different elements in the input increased by the number of intervals containing at least one duplicate.\nThe second is based on a simple, greedy approach, where we analyze the elements in nondecreasing order. While analyzing, we keep the set of elements for which we have already decided its value. When we want to add the next element, then we check if it is in the set. If it is, we increase it by \n1\n; otherwise, we keep it as it is.", "id": "1466B", "url": "https://codeforces.com/contest/1466/problem/B"}
{"plan": "If there are no occurrences of \na\n, \nb\n or \nc\n in \nS\n, sort \nS\n and output it.\nElse, if \nT \\ne\n \nabc\n, sort \nS\n and output it.\nElse, output all \na\n, then all \nc\n, then all \nb\n, then the rest of the string sorted.", "id": "1617A", "url": "https://codeforces.com/contest/1617/problem/A"}
{"plan": "Let's think: what properties do all interesting numbers have? Well, if a number \nx\n does not end with \n9\n, we can say for sure that \nf(x+1) = f(x) + 1\n, because the last digit will get increased. What if the number ends with \n9\n? Then the last digit will become \n0\n, so, no matter what happens to other digits, we can say that \nf(x+1)\n will surely be less than \nf(x)\n. \nSo the problem asks us to count all numbers \n1 \\le x \\le n\n with the last digit equal to \n9\n. It is not hard to see that the answer is equal to \n\\lfloor \\frac{n + 1}{10} \\rfloor\n. \nThis concludes the solution, as we are now able to answer all testcases in \nO(1)\n, resulting in total \nO(t)\n runtime. ", "id": "1553A", "url": "https://codeforces.com/contest/1553/problem/A"}
{"plan": "We can re-word the problem to count the number of numbers from \nb, c, d\n that are larger than \na\n. A possible way to do this is by keeping a variable that gets incremented every time we checked using the if statement whether a number is larger than \na\n. The complexity is \n\\mathcal{O}(1)\n.", "id": "1692A", "url": "https://codeforces.com/contest/1692/problem/A"}
{"plan": "Let's solve the problem for the first candidate. To win the election, he needs to get at least \n1\n more votes than every other candidate. Therefore, the first candidate needs to get at least \n\\max(b, c) + 1\n votes. If \na\n is already greater than this value, then you don't need to add any votes, otherwise, you need to add \n\\max(b, c) + 1 - a\n votes. So the answer for the first candidate is \n\\max(0, \\max(b,c) + 1 - a)\n.\nSimilarly, the answer for the second candidate is \n\\max(0, \\max(a, c) + 1 - b)\n, and, for the third one, the answer is \n\\max(0, \\max(a, b) + 1 - c)\n.", "id": "1593A", "url": "https://codeforces.com/contest/1593/problem/A"}
{"plan": "There are multiple ways to solve this problem.\nMost interpreted languages have some function that takes the string, evaluates it as code, and then returns the result. One of the examples is the \neval\n function in Python. If the language you use supports something like that, you can read the input as a string and use it as the argument of such a function.\nSuppose you use a language where this is impossible. There are still many approaches to this problem. The most straightforward one is to take the first and the last characters of the input string, calculate their ASCII codes, and then subtract the ASCII code of the character \n0\n from them to get these digits as integers, not as characters. Then you can just add them up and print the result.", "id": "1772A", "url": "https://codeforces.com/contest/1772/problem/A"}
{"plan": "Let's note that since all \na_i\n are positive, any \na_i + a_j > \\max(a_i, a_j)\n. It means that we can't make the first and second minimums lower than they already are: suppose the first and second minimums are \nmn_1\n and \nmn_2\n, if we choose any other element to replace, we can't make it less than \nmn_1 + mn_2\n and if we choose to replace \nmn_1\n or \nmn_2\n we will only make them bigger.\nAs a result, it means that we can choose for each element either not to change it or make it equal to \nmn_1 + mn_2\n. So, to be able to make all elements \n\\le d\n we need just check that either \nmn_1 + mn_2 \\le d\n or maximum \na_i \\le d\n.\nWe can do it, for example, by sorting our array \na\n in increasing order and checking that either \na_1 + a_2 \\le d\n or \na_n \\le d\n.", "id": "1473A", "url": "https://codeforces.com/contest/1473/problem/A"}
{"plan": "You can notice that the \n i \n-th number in the array will be included in the sum \ni\n times, which means that the value \n \\frac {a_i} {i} \n will add \n a_i \n to the sum. That is, the permutation of the elements does not affect the required sum, and therefore it is enough to check whether the sum of the array elements is equal to the given number.", "id": "1436A", "url": "https://codeforces.com/contest/1436/problem/A"}
{"plan": "To find a number that differs from the rest of the numbers in the array, you need to iterate through the array, maintaining two pairs of numbers \n(x_1, c_1)\n and \n(x_2, c_2)\n, where \nx_i\n is a number from the array, \nc_i\n is how many times the number \nx_i\n occurs in the array.\nThen, to get an answer, you need to find the position of the \nx_i\n that occurs in the array exactly once (i.e. \nc_i = 1\n).", "id": "1512A", "url": "https://codeforces.com/contest/1512/problem/A"}
{"plan": "In this problem, you can implement an algorithm opposite to that given in the condition. Let's maintain two pointers to the left-most and right-most unhandled element. Then, restoring the original array, you: \n \n put the left-most unhandled item in the first position \n put the right-most unhandled item in the second position \n put the left-most unhandled item in the third position \n put the right-most unhandled item in the fourth position \n ... \n That is, in general, you put the leftmost elements on all odd positions, and the rightmost ones on all even positions. After processing each element, you either move the left pointer forward by one, or the right one backward by one.", "id": "1462B", "url": "https://codeforces.com/contest/1462/problem/B"}
{"plan": "Notice that you may assume that the judge has sent a message at minute 0 and at minute 1440 and\nthis does not change the answer (but it simplifies the reasoning and the implementation).\nLet us consider two consecutive messages sent by the judge, at times s < t.\nIf t − s < 120, then the judge cannot have walked the dog between the two messages.\nIf 120 ≤ t − s < 240, then the judge may have walked at most once between the two messages.\nIf 240 ≤ t − s, then the judge may have walked the dog two times between the two messages.\nHence, if ai+1 − ai ≥ 240 for some i, then the answer is YES. If ai+1 − ai ≥ 120 for two distinct\nvalues of i, then the answer is YES. Otherwise the answer is NO.", "id": "1776A", "url": "https://codeforces.com/contest/1776/problem/A"}
{"plan": "For each index \ni\n (\nk + 1 \\le i \\le n\n), there is exactly one element among \na_1\n to \na_k\n, which can swap with \na_i\n. If \na_i\n is greater than that element, swap them. This process perform the operation at most \nn - k\n times. After performing operations, select \na_1\n to \na_k\n. This is the maximum score we can get.", "id": "1733A", "url": "https://codeforces.com/contest/1733/problem/A"}
{"plan": "You need to implement what is written in the statement. To quickly check if a word is written by another guy, you should store some \nmap<string, int>\n or Python dictionary, and increment every time you see a new string in the input. Then, you should iterate through each guy, find the number of times their word appears, and update their score. \nThe complexity is \n\\mathcal{O}(n \\log n)\n per testcase.", "id": "1722C", "url": "https://codeforces.com/contest/1722/problem/C"}
{"plan": "Suppose we can only perform exactly one operation. In this case the answer is \nS=\\max_{1\\le i\\le n}(a_i\\mathrm{\\ or\\ }z)\n. In fact, we can prove that this is the answer.\nDefine \na_i'\n as the value of \na_i\n after some operations.\nIt suffices to prove the answer will never exceed \nS\n. Note that \nz\n will always become a submask of itself after any number of operations, so \na_i\n will always be a submask of \n(a_i\\mathrm{\\ or\\ }z)\n after any number of operations. This leads to the conclusion that \na_i'\\le (a_i\\mathrm{\\ or\\ }z)\n for all \ni\n. Thus \n\\max_{1\\le i\\le n} a_i'\\le \\max_{1\\le i\\le n}(a_i\\mathrm{\\ or\\ }z)=S\n.\nTime complexity is \nO(n)\n.", "id": "1696A", "url": "https://codeforces.com/contest/1696/problem/A"}
{"plan": "Notice that only the following pairs of numbers are possible: \n(x, x)\n, \n(x, 2 \\cdot x)\n, and \n(x, 3 \\cdot x)\n.\n \nProof:\nLet \nd = gcd(a, b)\n. Now notice that it's impossible that \na = k \\cdot d\n for some \nk > 4\n, because otherwise \nlcm\n will be at least \nk \\cdot d > 3 \\cdot d\n. Therefore the only possible cases are the pairs listed above and \n(2 \\cdot d, 3 \\cdot d)\n, but in the latter case we have \nlcm = 6 \\cdot d\n.\nThe number of the pairs of the first kind is \nn\n, of the second kind is \n2 \\cdot \\lfloor \\frac{n}{2} \\rfloor\n, and of the third kind is \n2 \\cdot \\lfloor \\frac{n}{3} \\rfloor\n (the factor \n2\n in the latter two formulae arises from the fact that pairs are ordered). Therefore, the answer to the problem is \nn + 2 \\cdot \\left( \\lfloor \\frac{n}{2} \\rfloor + \\lfloor \\frac{n}{3} \\rfloor \\right)\n.", "id": "1717A", "url": "https://codeforces.com/contest/1717/problem/A"}
{"plan": "Let's first determine whether it's possible for two trains that start from \n(i,0)\n and \n(0,j)\n to crash into each other. For this to happen, there must be a point where \n(i,T)=(T,j)\n, which means \ni=T\n and \nj=T\n. Therefore, a train that starts from the bottom end can crash into a train that starts from the left end if and only if they have the same train number. We can cancel either one of them to prevent that crash.\nSince \nn\n and \nm\n are small, we can brute-force every pair of trains and count the number of pairs of trains that share the same number, and print that value as the answer. The time complexity for this solution is \n\\mathcal{O}(nm)\n for each test case.\nIf we want an asymptotically faster solution, we can put all train numbers into a binary search tree structure (such as \nstd::set\n in C++), and then find duplicate numbers from the trains of the other side by searching for those values. Another similar solution is to sort the former numbers, then perform binary search for the other values. The time complexity for these solutions is \n\\mathcal{O}((n+m)\\log(n))\n.\nThere is another solution with \n\\mathcal{O}(n+m)\n time complexity taking advantage of the fact that the train numbers are small. Let's make an array \nX\n of length \n101\n, and set \nX[i] = true\n if and only if there is a train starting from \n(i, 0)\n. For each train starting from \n(0, j)\n, we can check if \nX[j]\n is \ntrue\n, and count the total number of duplicates this way.", "id": "1453A", "url": "https://codeforces.com/contest/1453/problem/A"}
{"plan": "The answer is never greater than \n2\n, because \n\\text{MEX}\n of the whole string is not greater than \n2\n.\nThe answer is \n0\n only if there are no zeroes in the string.\nNow we need to understand, when the answer is \n1\n or when it is \n2\n. The sum of \n\\text{MEX}\n is \n1\n only if all zeroes create a single segment without ones. Then we can cut this segment out, its \n\\text{MEX}\n is \n1\n, everything else is ones, their total \n\\text{MEX}\n is \n0\n.\nIf the zeroes do not create a single segment without ones, the there are two such zeroes that there is a \n1\n between them. Then either these zeroes are in a single segment with the \n1\n, so total \n\\text{MEX}\n is not less than \n2\n or these zeroes are in different segments and the answer is still not less then \n2\n.", "id": "1566B", "url": "https://codeforces.com/contest/1566/problem/B"}
{"plan": "Consider two cases: \n \n The array is already sorted. \n THe array is \nnot\n sorted. \nIn the first case, sorting any prefix and any suffix does not change the array. So the array will always remain sorted so the answer is \"NO\".\nIn the second case, there are two elements with indexes \ni\n and \nj\n, such that \ni < j\n and \na_i > a_j\n. So choose \nlen\n so that these two elements will be in different parts. For example — \nlen = i\n. Note that after operation \na_i\n will remain to the left of \na_j\n, which means the array will not be sorted. So the answer is \"YES\".\nThen the solution is to check if the array is sorted, which can be done in \nO(n)\n.", "id": "1637A", "url": "https://codeforces.com/contest/1637/problem/A"}
{"plan": "Let us consider the ending state of the game. It turns out that at the ending state, we will only have logs of \n1\n meter. Otherwise, players can make a move.\nNow, at the ending state of the game, we will have \n\\sum\\limits_{k=1}^n a_k\n logs. And each move we increase the number of logs by exactly \n1\n. Since we started with \nn\n logs, there has been exactly \n(\\sum\\limits_{k=1}^n a_k) - n\n turns.\nAlternatively, a log of length \na_k\n will be cut \na_k-1\n times, so there will be \n\\sum\\limits_{k=1}^n (a_k-1)\n turns.\nIf there were an odd number of turns \n\\texttt{errorgorn}\n wins, otherwise \n\\texttt{maomao90}\n wins.", "id": "1672A", "url": "https://codeforces.com/contest/1672/problem/A"}
{"plan": "Let \ns\n be the sum of all digits. In one operation we can decrease \ns\n by at most \n1\n and we are finished iff \ns = 0\n. This leads us to a conclusion that it is always unoptimal to decrease the number on the clock, when the least significant digit shows \n0\n, since it will cost us at least \n9\n more operations.\nUsing this observation, the following strategy turns out to be optimal: \n \n if the least significant digit is positive, decrease the number by \n1\n \n if the least significant digit equals \n0\n, swap it with some positive digit \nLet \np\n be the number of digits that are positive and aren't the least significant digit. Our answer will be \ns + p\n. This can be computed in \nO(n)\n.", "id": "1573A", "url": "https://codeforces.com/contest/1573/problem/A"}
{"plan": "Let us simulate the process. We store a set \nv\n consisting of letters that Polycarp memorizes on one day. Gradually dial the set \ns\n. If the size of \nv\n exceeds \n3\n, we add \n1\n to the day counter \nans\n and clear \nv\n.", "id": "1702B", "url": "https://codeforces.com/contest/1702/problem/B"}
{"plan": "The first spell looks pretty weak compared to the second spell. Feels like you almost always replace one with another. Let's show that you can totally avoid casting the spell of the first type twice or more on one monster.\nLet the two first spell casts be \n(i, j)\n and \n(i, k)\n for some monsters \ni, j\n and \nk\n. You can replace them by a cast of the second spell on \ni\n and a cast of the first spell on \n(j, k)\n. That would deal even more damage to \ni\n and the same amount to \nj\n and \nk\n. The number of casts doesn't change.\nThus, it only makes sense to use the first spell on monsters with \n1\n health. Calculate the number of them, kill the full pairs of them with the first spell, and use the second spell on the remaining monsters.\nOverall complexity: \nO(n)\n per testcase.", "id": "1792A", "url": "https://codeforces.com/contest/1792/problem/A"}
{"plan": "We can prove that \ng \\leq 2\n.\n \nProof\nAssuming \ng > 2\n:\n \n \nIf there exists a prime number \np > 2\n that \np \\mid g\n, there are \n\\left \\lfloor \\dfrac{n}{p} \\right \\rfloor\n numbers divisible by \np\n, so we can match at most \n2 \\left \\lfloor \\dfrac{n}{3} \\right \\rfloor\n numbers into pairs, which is smaller than \nn\n.\n \nOtherwise, we can match odd numbers with even positions, and even numbers with odd positions, which leads to \n2 \\mid g\n. Because \np_2\n is odd, \n2 \\cdot p_2\n is not divisible by \n2^k\n with \nk > 1\n.\n \nTherefore, \ng\\leq 2\n.\nTherefore:\n \n \nIf \nn\n is odd, the answer is \n0\n since the number of odd is greater than the number of even.\n \nOtherwise, we will match odd with even and vice versa. For odd number in even position, we have \n(\\dfrac{n}{2})!\n ways. According to the multiplicative rule, the answer will be \n((\\dfrac{n}{2})!)^2\n.\n ", "id": "1658B", "url": "https://codeforces.com/contest/1658/problem/B"}
{"plan": "The answer is \na_1 | a_2 | \\cdots | a_n\n. Here is the proof:\nLet \nm = a_1 | a_2 | \\cdots | a_n\n. After an operation, the value \nm\n won't change.\nSince, \na_1 | a_2 | \\cdots | a_n \\leq a_1 + a_2 + \\cdots + a_n\n, the sum of the array has a lower bound of \nm\n. And this sum can be constructed easily: for all \ni \\in [1, n - 1]\n, set \na_{i+1}\n to \na_i | a_{i+1}\n and \na_i\n to \n0\n.", "id": "1635A", "url": "https://codeforces.com/contest/1635/problem/A"}
{"plan": "We can notice that to make the array sorted we must move all the negative signs to the beginning of the array. So let's say the number of negative elements is \nk\n. Then we must check that the first \nk\n elements are non-increasing and the remaining elements are non-decreasing.\nComplexity is \nO(n)\n.", "id": "1670A", "url": "https://codeforces.com/contest/1670/problem/A"}
{"plan": "Let's call a set of cells being filled from the topmost row to the leftmost column a \nlayer\n. E. g. the \n1\n-st layer consists of the single number \n1\n, the \n2\n-nd layer consists of the numbers \n2\n, \n3\n and \n4\n, the \n3\n-rd layer consists of the numbers \n5\n, \n6\n, \n7\n, \n8\n and \n9\n, etc.\nThe number of cells in layers forms an arithmetic progression. The first layer consists of \na_1 = 1\n cells, the \ni\n-th layer consists of \na_i = a_{i-1} + 2\n cells. The minimum number in the \ni\n-th layer \nx_i\n is equal to the sum of sizes of all layers from the \n1\n-st to the \n(i - 1)\n-th plus \n1\n.\nSuppose that \nk\n belongs to the \ni\n-th layer. Consider the value of \nm = k - x_i + 1\n. Polycarp fills exactly \ni\n cells on the \ni\n-th layer before he starts filling the cells from the right to the left (i. e. while he goes down). Therefore, if \nm \\le i\n, the number \nk\n belongs to the \nm\n-th row and the \ni\n-th column. Otherwise, the number belongs to the \ni\n-th row and the \n(i - (m - i))\n-th column.\nConsider a way to find the coordinates of a given number \nk\n. Let's iterate by the layer number \ni\n to which given the number belongs calculating the values of \na_i\n and \nx_i\n (going to the next layer, let's calculate the next layer parameters as follows: \nx_{i + 1} := x_i + a_i\n; \na_{i + 1} := a_i + 2\n). The iteration must be stopped if the layer number \ni\n is such that \nx_i \\le k < x_{i + 1}\n. Using the values of \ni\n and \nx_i\n, we can calculate the given number's coordinates in the described way in \nO(1)\n. The total time of calculating the coodrinates for one given \nk\n is \nO(i_k)\n where \ni_k\n is the number of the layer to which the given \nk\n belongs.\nLet's represent the value of \nx_i\n as \nx_i = f(i)\n: \nx_i = 1 + \\sum\\limits_{j = 1}^{i - 1} a_j = 1 + \\sum\\limits_{j = 1}^{i - 1} (2j - 1) = 1 + \\frac{1 + 2(i - 1) - 1}{2} \\cdot (i - 1) = 1 + (i - 1)^2\n. \n1 + (i_k - 1)^2 = x_{i_k} \\le k < x_{i_k + 1} = 1 + i_k^2\n, hence \ni_k \\approx \\sqrt(k)\n. Therefore, the coordinates of one number \nk\n may be calculated in \nO(\\sqrt{k})\n. At the same time, as it follows from the formulas, the layer number \ni_k\n can be calculated as follows: \ni_k = \\lceil \\sqrt{k} \\rceil\n (the square root of \nk\n rounded up). To avoid accuracy problems, you can calculate the value using a loop.", "id": "1560C", "url": "https://codeforces.com/contest/1560/problem/C"}
{"plan": "Let's define \ncnt\n to represent the number of 1s in the array.\nFor the modifications, if \na_i\n is already \n1\n now, then we let \ncnt \\gets cnt - 1\n. Otherwise, let \ncnt \\gets cnt + 1\n.\nFor the querys, just compare \ncnt\n with \nk\n. If \ncnt \\ge k\n, the answer will be \n1\n. Otherwise, the answer will be \n0\n.\nThe complexity : \nO(n + q)\n.", "id": "1491A", "url": "https://codeforces.com/contest/1491/problem/A"}
{"plan": "Let's prove that the color with the maximum value of \ncnt\n is one of the possible answers. \nLet the color \nx\n have the maximum value of \ncnt\n; if there are several such colors, choose any of them. Let's keep taking the balls of two different colors out of the bag without touching the balls of color \nx\n for as long as possible.\nAfter such operations, two cases exist. In one case, only balls of color \nx\n are left — then everything is fine. In other case, there are balls of color \nx\n and some color \ny\n (let \ncnt_y\n be the remaining number of balls of this color). Since initially \ncnt_x\n was one of the maximums, \ncnt_y \\le cnt_x\n. However, the number of remaining balls is odd, which means \ncnt_y \\ne cnt_x\n and \ncnt_y < cnt_x\n. Therefore, we can keep taking the balls of colors \ny\n and \nx\n until only balls of color \nx\n are left.", "id": "1728A", "url": "https://codeforces.com/contest/1728/problem/A"}
{"plan": "In the problem, you had to find the largest common prefix(LCP) of the first \n30\n characters of the number \n\\pi\n and the string \nn\n. To do this, we will go from the beginning and compare the characters until we find a non-matching one, or until the string \nn\n ends.", "id": "1790A", "url": "https://codeforces.com/contest/1790/problem/A"}
{"plan": "Key Idea:\nFor \nn > 3\n, the answer is \n2\n when \nn\n is even and \n3\n when \nn\n is odd. Cases when \nn \\leq 3\n can be handled separately.\nSolution:\nCase 1: \nn \\leq 3\nFor \nn = 1, 2, 3\n, it can be shown that the minimum number of operations required are \n0\n, \n1\n, \n2\n respectively.\nCase 2: \nn > 3\n and \nn\n is even\nIf \nn\n is even and greater than \n2\n, then \n\\frac{n}{2}\n is a proper divisor. So we can divide \nn\n by \n\\frac{n}{2}\n to make it \n2\n and then subtract \n1\n. This requires \n2\n operations.\nCase 3: \nn > 3\n and \nn\n is odd\nIn this case, \nn\n can be made even by subtracting \n1\n. From case 2, it can be seen that it will take \n2\n more operations. Thus a total of \n3\n operations are required.\nTime complexity: \nO(1)\n per case", "id": "1451A", "url": "https://codeforces.com/contest/1451/problem/A"}
{"plan": "We claim that we can sort the array if and only if \na_1 = 1\n.\nNecessity\nWe can notice that index \n1\n cannot be affected by any swap operation.\nLet's see what happens to the value \n1\n. According to the definition of the operation, it can either increase or be swapped. In order to be increased, there must exist some \nk\n such that \n1 > a_k\n, but since \n1\n is the minimum possible value, it will never be true as other values in array \na\n can only increse as well. Since index \n1\n can not be affected by a swap operation and \na_1>1\n, we conclude that if \na_1 \\neq 1\n, the answer is \nNo\n.\nSufficiency\nLet's focus on the second operation. Since we have \na_1 = 1\n, we can always choose \ni=1\n and the operation then turns into picking some pair \n2 \\le j < k \\le n\n and swapping \na_j\n with \na_k\n. It's trivial to see we can always sort with such an operation.", "id": "1750A", "url": "https://codeforces.com/contest/1750/problem/A"}
{"plan": "For convenience let's define going upward as decreasing \nx\n coordinate, downward — increasing \nx\n, left — decreasing \ny\n, right — increasing y.\nOne of the optimal solutions is the following:\n \n \nMegan goes upward to Stanley, she spends \n(n - 1)\n units of energy for that. Then she goes right to her final destination by spending \n(m - 1)\n more units of energy.\n \nStanley now has a choice: he obviously has to teleport from his starting position either all the way down, or right. He chooses what will save him the most energy, so he teleports along the greater wall of the shop for the 1 unit of power.\n \nThen Stanley has to finish his route: he walks along the smaller side and spends \nmin(n, m) - 1\n more energy.\n \nIf at least one of the dimensions is not \n1\n, then the answer is \n(n - 1) + (m - 1) + 1 + (min(n, m) - 1) = min(n, m) + n + m - 2\n. In case where \n(n, m) = (1, 1)\n answer is \n0\n.\n \nNormal proof\n1715A - Crossmarket\nObviously, except for 1 case, it is always beneficial for Stanley to use teleportation. Let the first portal he visited be \nA\n, and the last is \nB\n. It is also obvious, that teleporting for more than 1 time makes no sense, so that's why we consider, that he always teleports from \nA\n to \nB\n and that's it.\nFor the sake of convenience let's define manhattan distance between two points as \ndist(P_1, P_2) = |{P_1}_x - {P_2}_x| + |{P_1}_y - {P_2}_y|\n.\nConsider the next few cases for the relative position of those two portals:\n \n \nA_x \\le B_x\n and \nAy > By\n \nMegan must make at least \n(n-1) + (m-1)\n moves. The portal does not help Stanley in the \ny\n direction, so he must make at least \n(m-1)\n moves.\n \n \nA_x > B_x\n and \nA_y \\le B_y\n \nMegan must make at least \n(n-1) + (m-1)\n moves. The portal does not help Stanley in the \nx\n direction, so he must make at least \n(n-1)\n moves.\n \n \nA_x \\le Bx\n and \nAy \\le By\n \nMegan must make at least \ndist(A,B)\n moves between \nA\n and \nB\n. Going between A and B either undoes Megan's progress in the \nx\n direction or \ny\n direction (depending on which is visited first), so she must make at least an additional \n(n-1) or (m-1)\n moves. Stanley must make at least \n(n-1) + (m-1) - dist(A,B)\n moves.\n \n \nAx > Bx\n and \nAy > By\n \nMegan must make at least \n(n-1) + (m-1)\n moves. Using the portal undoes Stanley's progress in both the x and y directions, so he must make at least \n(n-1) + (m-1)\n moves.\nIn all cases, the total number of moves is at least (n-1) + (m-1) + min(n-1, m-1).\n \nProof, director's cut (or how you should not do)\nIn a while, after I came up with an idea for this task, I got excited to proof it formally. I was very happy with the result — A's proof was longer than a regular editorial for Fdiv2, or even Fdiv1. A couple of days before the round \nMonogon\n told us that there is a solution much easier to understand, for which I am very grateful! But I would like to save the original version as an example, of how you should not prove the easiest task in your contest. \n1715A - Crossmarket\nProof:\nTo start with, Stanley and Megan can complete their steps in any order. So, again, for our convenience let's reorder their moves in such a way, that firstly Megan finishes her route and places portals, and then Stanley does what he needs to do.\nWhat is always the optimal route for Stanley? He goes to the nearest cell with the teleport and then teleports to the nearest possible cell to his finish. \nIt is obvious, that Stanley can always complete his route without going left or up (except for the teleportations).\nLet's try to prove a similar statement for Megan: she can always plan her route avoiding moves left or down. These two cases are almost equivalent, so we will consider the first one.\nLet's assume that teleportations are free for Megan. Consider any cell, from which she made her move to the left. Then it is possible to \"shift\" a segment of the route to the right in order to decrease its length at least by one in conjunction with getting rid of at least one move to the left. More formally we need to construct a new route for her, so the following conditions are met: for each cell in the previous route either itself, or her right neighbor is included in the new route. This can be done by the following algorithm: we will consider cells from the original route \nA\n in order of installation of the portals, and build the new route \nB\n in parallel. If we cannot include the cell \n(x, y)\n from \nA\n to the route \nB\n because it does not have adjacent sides to any of the cells from \nB\n. Then we can include the cell \n(x, y + 1)\n to \nB\n (it cannot be out of bounds). Let there be a cell \n(x_1, y_1)\n in \nA\n with a portal, that was installed earlier than in our current cell, and that is adjacent to our current cell. If we could not include cell \n(x, y)\n to the route \nB\n, that it means that we also did not include the cell \n(x_1, y_1)\n there, thus cell \n(x_1, y_1 + 1)\n is in \nB\n, that also also allows us to include cell \n(x, y + 1)\n.\nAfter such an operation Stanley's energy consumption could increase \nat most\n by 1. Though energy spent by Megan decreased \nat least\n by one. That means that our new route is not more energy-consuming. \nThat way Megan will never go left or down, so she will spend at least \n(n - 1) + (m - 1) = n + m - 2\n units of power.\nIf, when all the operations are applied, Stanley teleports from the cell \n(x_1, y_1)\n to \n(x_2, y_2)\n, then \n \\left[ \\begin{array}{c} x_1 \\le x_2, y_1 \\ge y_2 \\\\ x_1 \\ge x_2, y_1 \\le y_2 \\\\ \\end{array} \\right. \n. In the first case he teleports along Megan's route and approaches his finish by \n(x_2 - x_1) - (y_1 - y2)\n, and in the second case he teleports across Megan's route and approaches his destination by \n(y_2 - y_1) - (x_1 - x2)\n. As you can easily notice, first's expression maximum is \nn - 1\n, and second's is \nm - 1\n. Hence Stanley will spend at least \n(n - 1) + (m - 1) - max(n - 1, m - 1) = n + m - max(n, m) - 1\n units of power. After adding only teleportation we get \nn + m - max(n, m)\nWe got two lower bounds, that in sum are \nn + m - 2 + n + m - max(n, m) = 2n + 2m - max(n, m) - 2 = n + m + min(n, m) - 2\n, which is not better, than our solution's answer, even though we did not consider Megan's teleportations.", "id": "1715A", "url": "https://codeforces.com/contest/1715/problem/A"}
{"plan": "The answer is the number of \n1\ns modulo \n2\n.\nWe can get that by adding '-' before the \n\\text{2nd}, \\text{4th}, \\cdots, 2k\\text{-th}\n \n1\n, and '+' before the \n\\text{3rd}, \\text{5th}, \\cdots, 2k+1\\text{-th}\n \n1\n.", "id": "1774A", "url": "https://codeforces.com/contest/1774/problem/A"}
{"plan": "If we take two elements \na_1\n and \na_2\n and do the operation on it as \na_1 \\cdot a_2 = x \\cdot y\n, then it is easy to observe that \nx + y\n will attain its maximum value when one of them is equal to \n1\n. So, the solution for this is \nx = 1\n and \ny = a_1 \\cdot a_2\n.\nLet \nn\n be the total number of elements and \nP\n (\nP = a_1 \\cdot a_2 \\cdot \\ldots \\cdot a_n\n) be the product of all elements.\nNow if we do the above step for every pair of elements, then the maximum value of the sum is achieved when \na_1 = 1\n, \na_2 = 1\n, \n\\dots\n, \na_{n-1} = 1\n and \na_n = P\n.\nIn the final array, assign \nP\n to \na_1\n and assign \n1\n to all the remaining elements \na_2, a_3, \\dots a_n\n.\nSo, our answer is simply \nP + n - 1\n multiplied by \n2022\n, of course.\nTime complexity: \nO(n)\n.", "id": "1731A", "url": "https://codeforces.com/contest/1731/problem/A"}
{"plan": "Considering an array \na\n of \nn\n (\nn\\geq 2\n) positive integers, the following inequality holds for \n2\\leq i\\leq n\n:\n \n \\gcd(a_1,a_2,\\cdots,a_i) \\leq \\gcd(a_1,a_2) \\leq 2 \nTherefore, when the prefix \n[a_1,a_2]\n of \na\n is good, we can show that all the prefixes of \na\n whose length is no less than \n2\n are good, then \na\n is beautiful. It is obvious that \n[a_1, a_2]\n is good when \na\n is beautiful. So we get the conclusion that \na\n is beautiful if and only if the prefix \n[a_1, a_2]\n is good.\nWe can check if there exist \na_i, a_j\n (\ni\\neq j\n) such that \n\\gcd(a_i, a_j)\\leq 2\n. If so, we can move \na_i,a_j\n to the front of \na\n to make it beautiful, then the answer is \nYes\n. If not, the answer is \nNo\n.\nTime complexity: \nO(n^2\\log 10^6)\n.", "id": "1789A", "url": "https://codeforces.com/contest/1789/problem/A"}
{"plan": "For this problem you just need to implement what it asks you. To be able to implement it you need to know about the \"if\" statement.", "id": "1669A", "url": "https://codeforces.com/contest/1669/problem/A"}
{"plan": "The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std::rotate function. So you can obtain the final deck by applying cyclic shifts of the deck by \nb_1\n, then \nb_2\n and so on.\nSince the shifts are cyclic, it doesn't matter if you shift by \nx\n or by \nx + n\n or by \nx + k \\cdot x\n for any non-negative \nk\n. The result will be the same. Thus, you can calculate the sum of rotations you apply, and subtract \nn\n, until it becomes less than \nn\n. That is taking it modulo \nn\n.\nFinally, after rotating a sequence by some \nx\n, the \nx\n-th element of it (\n0\n-indexed) becomes the first one. Thus, you just want to print the (\nsum \\bmod n\n)-th element of \na\n.\nOverall complexity: \nO(n + m)\n per testcase.", "id": "1681B", "url": "https://codeforces.com/contest/1681/problem/B"}
{"plan": "If the number is already even, then nothing needs to be done, so the answer in this case is \n0\n.\nNow let's recall the divisibility by \n2\n: a number is divisible by \n2\n if and only if its last digit is divisible by \n2\n.\nIt follows that if there are no even digits in our number, then the answer is \n-1\n.\nLet's take a look at our operation. What is going on? The first digit always changes with the digit numbered \nl\n. In particular, when we reverse the entire number, the first digit is swapped with the last. Note that no other digit, except for the first one at the current moment, can't be the last.\nTherefore, you can do this: if the first digit of a number is divisible by \n2\n, then we reverse the whole number. The first digit will become the last, and the number will become even. Therefore, you only need to do one operation.\nNow, what if the first digit of a number is odd? In this case, we can find the first even digit in the number (let it be at position \nx\n), and reverse the prefix of length \nx\n (in one operation). Now the first digit of our number has become even, and we can use the previous case (one more operation). Thus, we will do only \n2\n operations.", "id": "1611A", "url": "https://codeforces.com/contest/1611/problem/A"}
{"plan": "The answer is the sum of the \n2\n maximum weights.\nYou can always pick the \n2\n maximum weights: if they are \na_i\n and \na_j\n (\ni < j\n), you can flip the subsegment \n[i, j-1]\n to make them adjacent.\nThe result can't be larger, because the sum of the weights of any \n2\n pieces of cake is never greater than the sum of the \n2\n maximum weights.\nIterating over all pairs of pieces of cake is enough to get AC, but you can solve the problem in \nO(n \\log n)\n by sorting the weights and printing the sum of the last \n2\n values, or even in \nO(n)\n if you calculate the maximum and the second maximum in linear time.\nComplexity: \nO(t \\cdot n^2)\n, \nO(t \\cdot n \\log n)\n or \nO(t \\cdot n)", "id": "1654A", "url": "https://codeforces.com/contest/1654/problem/A"}
{"plan": "First, note that \nm\n is always less than or equal to \nn\n. If there were at least \nn+1\n rooks on the board, at least two of them would share a row or a column (by pigeonhole principle).\nIf \nm < n\n, then there is always at least one free row and at least one free column. You can move any rook into that row or column.\nOtherwise, all rows and columns are taken, so any move will make two rooks share a row or a column, which is prohibited.\nThus, if \nm = n\n, then it's \"\nNO\n\". Otherwise, it's \"\nYES\n\".\nOverall complexity: \nO(1)\n per testcase.\nAlternatively, you could check every rook and every possible move.\nOverall complexity: \nO(m^2 \\cdot n^2)\n per testcase.", "id": "1749A", "url": "https://codeforces.com/contest/1749/problem/A"}
{"plan": "If there are two elements with the same value, then the answer is \nNO\n, because neither of these values is less than the other.\nOtherwise, the answer is \nYES\n, since we can just sort the array.\nThe time complexity is \n\\mathcal{O}(n \\log n)\n or \n\\mathcal{O}(n)\n depending on the implementation.", "id": "1742B", "url": "https://codeforces.com/contest/1742/problem/B"}
{"plan": "For any permutation \np\n of length \nn\n, the final sum \np_1 + p_2 + \\ldots + p_k\n after some number of operations can't be less than \n1 + 2 + \\ldots + k\n. \nThis means that we need to apply the operation at least once for every \ni\n such that \n1 \\le i \\le k\n and \np_i > k\n. Every time we apply it, we have to choose some index \nj\n such that \nk < j \\le n\n and \np_j \\le k\n. \nThis is always possible since initially the number of suitable \ni\n is equal to the number of suitable \nj\n, and one operation decreases both the number of suitable \ni\n and the number of suitable \nj\n by one. \nIt is easy to see that in the end, the set \n\\{p_1, p_2, \\ldots, p_k \\}\n only contains the values \n\\{1, 2, \\ldots , k \\}\n, which means that the sum is equal to \n1 + 2 + \\ldots + k\n, which is the smallest sum we can get.\nSo the answer is the the number of \ni\n such that \n1 \\le i \\le k\n and \np_i > k\n.\nComplexity: \n\\mathcal{O}(n)", "id": "1712A", "url": "https://codeforces.com/contest/1712/problem/A"}
{"plan": "We will perform each move in reverse from the final sequence of the cypher. \n \n \ndown\n move: it increases the \ni\n-th digit by \n1\n. After applying the up move on \n9\n, it becomes \n0\n. \n \nup\n move (denoted by \n\\texttt{D}\n): it decreases the \ni\n-th digit by \n1\n. After applying the down move on \n0\n, it becomes \n9\n. \n Now we just need to implement the two types of moves. The time complexity is \n\\mathcal{O}(n + \\sum a_i)\n per test case.", "id": "1703C", "url": "https://codeforces.com/contest/1703/problem/C"}
{"plan": "It is easy to observe that the second operation needs to be performed \nat most\n once. Now, we just need to check \n2\n cases, one in which the re-arrangement operation is used, and one in which it is not.\nIf the re-arrangement operation is to be used, then we just need to make the counts of \n0\ns and \n1\ns in \na\n equal to that of \nb\n. Without loss of generality assume \na\n contains \nx\n more \n0\ns than \nb\n, then the cost in this case will just be \nx + 1\n (extra one for re-arrangement cost).\nIf the re-arrangement operation is not to be used, then we just need to make each element of \na\n equal to the corresponding element of \nb\n.\nFinally, our answer is the smaller cost of these \n2\n cases.\nTime complexity is \nO(n)\n.", "id": "1736A", "url": "https://codeforces.com/contest/1736/problem/A"}
{"plan": "Note that if \n\\left\\lfloor \\frac{l}{a} \\right\\rfloor < \\left\\lfloor \\frac{r}{a} \\right\\rfloor\n then exists such \nk \\cdot a\n that \nl \\le ka \\le r\n and, obviously, a customer, who wants to buy \nka\n cans won't buy more than he wants.\nThat's why \n\\left\\lfloor \\frac{l}{a} \\right\\rfloor = \\left\\lfloor \\frac{r}{a} \\right\\rfloor\n and we can rephrase our task as finding such \na\n that \n\\frac{a}{2} \\le (l \\bmod a) \\le (r \\bmod a) < a\n. The longer the segment \n[\\frac{a}{2}, a)\n is the better and the maximum we can take is \na = 2l\n. \nAs a result, we need to check that \nr < a \\leftrightarrow r < 2l\n.", "id": "1437A", "url": "https://codeforces.com/contest/1437/problem/A"}
{"plan": "If we cut the sheet in width, we will reduce its width by half, without changing the height. Therefore, the width and height dimensions do not affect each other in any way.\nLet's calculate the maximum number of sheets that we can get by cutting. Let's say that initially this number is \n1\n. Let's cut the sheet in width. Then the sheets number will become \n2\n, but they will be the same. If we can cut the sheet again, it is more profitable to cut all the sheets we have, because this way we will get more new sheets and their size will still be the same.\nSo we can maintain the current number of identical sheets and as long as either the width or height is divided by \n2\n, divide it, and multiply the number of sheets by two.", "id": "1472A", "url": "https://codeforces.com/contest/1472/problem/A"}
{"plan": "Suppose \n\\text{Count}(\\RED)=k\n. If a solution exists, then there is one with \n\\text{Count}(\\BLUE)=k+1\n, because if there are more than \nk+1\n numbers painted blue, we can remove some of them until we have exactly \nk+1\n numbers, and the sum of these numbers will be smaller. \nAs we want \n\\text{Sum}(\\RED) > \\text{Sum}(\\BLUE)\n to hold, the optimal way to paint the numbers is to paint the \nk\n largest numbers red, and the \nk+1\n smallest numbers blue. \nSo, to solve the problem it is enough to sort the sequence, iterate over the value of \nk\n and for each of them compute the sum of the \nk\n largest numbers, the sum of the \nk+1\n smallest numbers and compare them. This can be done efficiently by computing the sum of every prefix and suffix of the sorted sequence in linear time. This way, we can make a constant number of operations for each \nk\n.\nIntended complexity: \n\\mathcal{O}(n\\:\\text{log}\\:n)", "id": "1646B", "url": "https://codeforces.com/contest/1646/problem/B"}
{"plan": "It's always optimal to use two weapons with the highest damage value and switch between them.\nLet \nx\n be the highest damage value of a weapon, and \ny\n be the second-highest damage value of a weapon. we will decrease monster health by \nx\n in the first move, and by \ny\n in the second move and so on.", "id": "1592A", "url": "https://codeforces.com/contest/1592/problem/A"}
{"plan": "For a start, let's find the position of the letter '\na\n' in string \ns\n. If this position does not exist, then the answer would be '\nNO\n'. Suppose that this position exists and equals \n\\text{pos}_a\n. Let's create two pointers \nL\n and \nR\n. Initially \nL := \\text{pos}_a,~R := L\n. We will try to build string \ns\n using the algorithm from the statement. Suppose that we have built substring \ns[L..R]\n in \ni\n iterations. Consider the next letter of the Latin alphabet \nc_i\n. Let's look at cases: \n \n find position \npos\n of the letter \nc_i\n in \ns\n (if it does not exist then '\nNO\n'); \n if \npos = L - 1\n then make an assignment \nL := L - 1\n and process the next letter \nc_i\n; \n if \npos = R + 1\n then make an assignment \nR := R + 1\n and process the next letter \nc_i\n; \n otherwise string \ns\n is not alphabetical and the answer is '\nNO\n'. \n So, if we have built the string in \nn\n iteration, then string \ns\n is alphabetical and the answer is '\nYES\n'.", "id": "1547B", "url": "https://codeforces.com/contest/1547/problem/B"}
{"plan": "Consider any optimal splitting.\nClearly, for any subarray \n[b_1, b_2, \\ldots, b_m]\n which is not \nodd\n, we can just split it into \n[b_1], [b_2], \\ldots, [b_m]\n,\nFor any \nodd\n subarray \n[b_1, b_2, \\ldots, b_m]\n with \nm \\ge 3\n, there exists an \n1 \\le i \\le m-1\n such that \nb_i > b_{i+1}\n (otherwise \nb\n is sorted and has no inversions). Then, we can split \nb\n into \n[b_1], [b_2], \\ldots, [b_{i-1}], [b_i, b_{i+1}], [b_{i+2}], \\ldots, [b_m]\n, where we also have one odd subarray.\nSo, if we can split \np\n into several subarrays such that there are \nk\n odd subarrays, we can split it into several subarrays of length \n\\le 2\n so that there are \nk\n odd subarrays too. Then, let \ndp_i\n denote the largest number of odd subarrays we can get from splitting \np[1:i]\n. Then, \ndp_i = max(dp_{i-1}, dp_{i-2} + (p_{i-1} > p_i))\n. This \ndp\n can be calculated in \nO(n)\n.\nIt's also easy to show that the following greedy algorithm works: traverse the permutation from left to right, whenever you see two elements \np_{i-1}>p_i\n, make a subarray \n[p_{i-1}, p_i]\n, and proceed from \np_{i+1}\n.", "id": "1686B", "url": "https://codeforces.com/contest/1686/problem/B"}
{"plan": "At first, let's replace \na_i\n with \n|a_i|\n. Let \nf(x)\n denote the number of vaues in the array equal to \nx\n after the replacement (or, equal to \nx\n or \n-x\n before).\nThen, for the zero we can only get \n\\min(1, f(0))\n different values.\nAnd for any other number \nx > 0\n, we can get \n\\min(2, f(x))\n different numbers in the array.\nAs different absolute values are independent and bounded, to get the answer we just need to evalue the sum \n\\min(1, f(0)) + \\min(2, f(1)) + \\ldots + \\min(2, f(100))\n. It can be easily done using arrays, maintaning the number of occurences for each \n|x|\n.", "id": "1616A", "url": "https://codeforces.com/contest/1616/problem/A"}
{"plan": "Let \n\\texttt{sort}(s)\n be \ns\n sorted alphabetically. The answer to the problem is the number \nm\n of mismatches between \ns\n and \n\\texttt{sort}(s)\n (i.e., the positions with different characters in the two strings).\nChoosing \nk=m\n characters is sufficient.\n Let us choose the mismatched characters between \ns\n and \n\\texttt{sort}(s)\n, and permute them so that they are sorted alphabetically. It is not hard to prove that the resulting string will coincide with \n\\texttt{sort}(s)\n.\nChoosing strictly less than \nm\n characters is not sufficient.\n If \nk < m\n, by the Pigeonhole Principle at least one of the mismatched characters will be left out, and thus it will prevent the final string from being ordered alphabetically.\nComplexity:\n \nO(n\\log n)\n.", "id": "1552A", "url": "https://codeforces.com/contest/1552/problem/A"}
{"plan": "First, we need to check whether \nn\n is the multiple of \n2050\n. If \nn\n is not the multiple of \n2050\n, the answer is always \n-1\n.\nThen we can divide \nn\n by \n2050\n, the problem now is how to represent \nn\n as the sum of powers of \n10\n. So the answer is the sum of its digits in decimal representation.\n#", "id": "1517A", "url": "https://codeforces.com/contest/1517/problem/A"}
{"plan": "The maximum sum we can construct with \nn\n elements is \n1 + 3 + 5 + 7 + \\dots + 2n-1 = n^2\n, so we need at least \n\\lceil\\sqrt{s}\\rceil\n elements to construct the sum equal to \ns\n. Let's show how to express \ns\n with exactly \n\\lceil\\sqrt{s}\\rceil\n elements.\nLet \n\\lceil\\sqrt{s}\\rceil = d\n. By taking \n1 + 3 + 5 + 7 + \\dots + 2d-3\n, we achieve a sum of \n(d-1)^2\n using \nd - 1\n elements. \ns - (d-1)^2\n is not less than \n1\n and not greater than \n2d-1\n (since \n\\sqrt{(d-1)^2} = d-1\n, and \n\\sqrt{(d-1)^2 + 2d} > d\n). Thus, we can just add \ns - (d-1)^2\n to our array, and the sum becomes exactly \ns\n.\nSo, the solution is to find the minimum \nn\n such that \nn^2 \\ge s\n.", "id": "1550A", "url": "https://codeforces.com/contest/1550/problem/A"}
{"plan": "During the first stage, every player with an even index competes against a player with an odd index, so in each match during the first stage, the player whose index is smaller wins. The pairs are formed in such a way that, in each pair, the player with an odd index has smaller index, so all players with even indices get eliminated, and all players with odd indices advance to the next stage.\nAll of the remaining matches are between players with odd indices, so the winner of each match is the player with the larger index. So, the overall winner of the tournament is the player with the greatest odd index, which is \n2^n-1\n.\nNote: in some languages (for example, C++), standard power functions work with floating-point numbers instead of integers, so they will produce the answer as a floating-point number (which may lead to wrong formatting of the output and/or calculation errors). You might have to implement your own power function that works with integers, or compute \n2^n\n using a loop.", "id": "1651A", "url": "https://codeforces.com/contest/1651/problem/A"}
{"plan": "To solve this problem, let's use the following greedy algorithm.\nLet's sort the prices of chocolate bars in increasing order, after which we will go from left to right and take chocolates that have a price not less than \nl\n, but not more than \nr\n until we run out of money.\nThe number of chocolate bars that we took will be the answer to the problem.\nThe resulting asymptotics in time: \n\\mathcal{O}(n\\log{}n)\n.", "id": "1614A", "url": "https://codeforces.com/contest/1614/problem/A"}
{"plan": "Note that we never have a choice in what door should we open. First, we open the door with the same number as the key in our hand. Then, the door with the same number as the key behind the first opened door. Finally, the door with the same number as the key behind the second opened door.\nIf any of the first and second opened doors didn't have a key behind it, then it's impossible. Otherwise, we open every door.\nLet \na_1, a_2, a_3\n be the keys behind the corresponding doors. Then we should check if \na[x]\n is not zero and \na[a[x]]\n is not zero.\nOverall complexity: \nO(1)\n per testcase.", "id": "1709A", "url": "https://codeforces.com/contest/1709/problem/A"}
{"plan": "Let us add to \ns\n the sum of the elements of the array \nb\n and try to find a suitable permutation. To do this, greedily add elements \n1, 2, \\dots, cnt\n until their sum is less than \ns\n. And at the end we will check that the sum has matched. \nAlso check that the maximal element from \nb\n: \nmax(b) \\le cnt\n, and that the total elements in \nb\n: \nn \\le cnt\n.", "id": "1759B", "url": "https://codeforces.com/contest/1759/problem/B"}
{"plan": "We first sort the array \na\n in non-decreasing order.\nDenote the indices of the elements that we choose from \na\n to be \nx\n, \ny\n, and \nz\n, where \n1 \\le x < y < z \\le n\n, and the final value (after performing the operations) of the concerned elements to be \nv\n.\nThe minimum required number of operations is then \n|a_x-v|+|a_y-v|+|a_z-v|\n. It is well-known that such expression attains its minimum value when \nv\n is the median of \na_x\n, \na_y\n, and \na_z\n. Since the array \na\n has already been sorted, it is best to assign \nv\n to be \na_y\n.\nOur expression then becomes \n|a_x-a_y|+|a_y-a_y|+|a_z-a_y|=(a_y-a_x)+0+(a_z-a_y)=a_z-a_x\n. We would like to minimize the value of \na_z\n, which implies \nz\n should be as small as possible since \na\n is sorted. It is clear that taking \nz=y+1\n would minimize the value of the expression. Similarly, we can show that we can take \nx=y-1\n to minimize the value of the expression.\nTherefore, the only possible values of the triplets \n(x,y,z)\n are of the form \n(t,t+1,t+2)\n for positive integers \n1 \\le t \\le n-2\n, and we can iterate through all such triplets and find the best one. \nThe time complexity is ", "id": "1734A", "url": "https://codeforces.com/contest/1734/problem/A"}
{"plan": "Using some software is never bad. It always ends up increasing your RAM if you can use it. And for any possible order to use a set of software in, they all result in the same amount RAM in the end. So we can greedily go through the list, using software if you have enough RAM for it. After going through the list, your RAM may have increased, so maybe some of the software you couldn't use at the start is now usable. Therefore we have to go through the list again (now with the used software removed) until the RAM doesn't increase anymore. This results in time complexity \nO(n^2)\n, which is fine for these constraints.\nIt turns out we don't actually need to go through the list of software more than once if we sort it by \na\n. This results in \nO(n \\log n)\n time complexity.", "id": "1629A", "url": "https://codeforces.com/contest/1629/problem/A"}
{"plan": "The sum of an odd integer and an even integer is an odd integer. So, you can't have both even and odd elements in the array for the sum of every two consecutive elements to be even.\nHence, the final array should only contain \nall even\n or \nall odd\n elements. Hence, we will remove either all odd elements or all even elements, whichever takes lesser number of operations. Therefore, the answer is: \n.", "id": "1691A", "url": "https://codeforces.com/contest/1691/problem/A"}
{"plan": "Make a copy of the array \ns\n: call it \nt\n. Sort \nt\n in non-decreasing order, so that \nt_1\n is the maximum strength and \nt_2\n — the second maximum strength.\nThen for everyone but the best person, they should compare with the best person who has strength \nt_1\n. So for all \ni\n such that \ns_i \\neq t_1\n, we should output \ns_i - t_1\n. Otherwise, output \ns_i - t_2\n — the second highest strength, which is the next best person.", "id": "1760C", "url": "https://codeforces.com/contest/1760/problem/C"}
{"plan": "You should count the number of parentheses at the end of the string, suppose there are \nx\n such parentheses. Then if \nx > \\frac{n}{2}\n, message is bad. Note that you should divide \nn\n by \n2\n without rounding. Or you can compare \n2 \\cdot x\n and \nn\n instead. If \n2 \\cdot x > n\n, the message is bad.", "id": "1411A", "url": "https://codeforces.com/contest/1411/problem/A"}
{"plan": "There will be three cases in total, let's consider them on two types of candies:\n \na_1 = a_2\n, then we will eat candies in this order \n[1, 2, 1, 2, \\ dots, 1, 2]\n \na_1 = a_2 + 1\n, then we will eat a candy of the type \n1\n, and then we will eat in this order \n[2, 1, 2, 1, \\dots, 2, 1]\n (almost as in the case above)\n \na_1 >= a_2 + 2\n, then we will eat a candy of the type \n1\n, but there will still be more of them than candies of the type \n2\n and we will have to eat a candy of the type \n1\n again. So the answer is \"\nNO\n\".\nNow we prove that it is enough to check these conditions on two maximums of the array \na\n. If the third condition is true, the answer is obvious \"\nNO\n\". Otherwise, we will by turns eat candies of the two maximum types until their number is equal to the third maximum, after which we will by turns eat candies of these three types and so on.", "id": "1660B", "url": "https://codeforces.com/contest/1660/problem/B"}
{"plan": "Note that whichever path you choose, the total cost will be the same. If you know that the cost is the same, then it's not hard to calculate it. It's equal to \nn \\cdot m - 1\n. So the task is to check: is \nk\n equal to \nn \\cdot m - 1\n or not.\nThe constant cost may be proved by induction on \nn + m\n: for \nn = m = 1\n cost is \n1 \\cdot 1 - 1 = 0\n. For a fixed \n(n, m)\n, there are only two last steps you can make: \n \n either from \n(n, m - 1)\n with cost \nn\n: the total cost is \nn \\cdot (m - 1) - 1 + n\n \n=\n \nn \\cdot m - 1\n \n or from \n(n - 1, m)\n with cost \nm\n: the total cost is \n(n - 1) \\cdot m - 1 + m\n \n=\n \nn \\cdot m - 1\n. \nSo, whichever path you choose, the total cost is the same.", "id": "1519B", "url": "https://codeforces.com/contest/1519/problem/B"}
{"plan": "Obviously, the best way to buy food for every pet is to buy maximum possible food for dogs and cats, then \nmax(0, x - a)\n dogs and \nmax(0, y - b)\n cats will not get food. We will buy universal food for these dogs and cats. Then the answer is \nYES\n, if \nmax(0, x - a) + max(0, y - b) \\le c\n, and \nNO\n else.", "id": "1675A", "url": "https://codeforces.com/contest/1675/problem/A"}
{"plan": "Let \np_i\n be the \ni\n-th bit of \nx\n, \nq_i\n be the \ni\n-th bit of \ny\n (both indexed from \n0\n).\nx\\ \\texttt{and}\\ y > 0\\Leftrightarrow \\exists i,\\ p_i= q_i = 1\n.\nx\\ \\texttt{xor}\\ y > 0\\Leftrightarrow \\exists i,\\ p_i\\ne q_i\n.\nTo satisfy the first condition, find the minimum integer \nk\n satisfying \np_k=1\n, and assign \n1\n to \nq_k\n.\nIf \nx\\ne 2^k\n, the second condition is satisfied now. Otherwise, find the minimum integer \nj\n satisfying \np_j=0\n, and assign \n1\n to \nq_j\n.\nThe time complexity is \nO(1)\n.", "id": "1688A", "url": "https://codeforces.com/contest/1688/problem/A"}
{"plan": "According to the problem, the arrays \na\n and \nb\n denote the dimensions of the rectangles. Define arrays \nc\n and \nd\n as a certain orientation configuration of the rectangles with \nc_i\n denoting the width and \nd_i\n denoting the height. Define arrays \ne\n and \nf\n as a certain permutation of the orientation configuration such that the \ni\n-th rectangle from the left has width \ne_i\n and height \nf_i\n.\nConsider a certain configuration of \ne\n and \nf\n. The perimeter of the connected shape will be \n2(e_1+e_2+\\ldots+e_n)+f_1+|f_1-f_2|+|f_2-f_3|+\\ldots+|f_{n-1}-f_n|+f_n\n.\nNotice that if we sort the rectangles based on \nf_i\n, the perimeter would become \n2(e_1+e_2+\\ldots+e_n+f_n)\n. This is actually the minimum possible perimeter for a fixed configuration of \nc\n and \nd\n as we cannot get a smaller perimeter than this. This means, if we have a certain configuration of \nc\n and \nd\n, the optimal perimeter is \n2(c_1+c_2+\\ldots+c_n+\\max(d))\n. Now, we just need to find a configuration of \nc\n and \nd\n from \na\n and \nb\n that results in the minimum value of \n2(c_1+c_2+\\ldots+c_n+\\max(d))\n.\nNotice that each element of \na\n and \nb\n can only be counted either \n0\n or \n2\n times in the final answer. Consider the maximum value out of all elements of \na\n and \nb\n. If there are multiple values that are maximum, just consider one of them. We can see that that value will always be counted \n2\n times no matter how we construct \nc\n and \nd\n.\nWe need to determine whether to put that maximum value in \nc\n (width) or \nd\n (height). It is actually better to put that value in \nd\n as it will cause all other values of \nd\n to be counted \n0\n times in the final answer.\nNow, we just need to determine the orientation for each of the other rectangles. We have determined that the maximum value in \na\n and \nb\n must be put in \nd\n, which will automatically become the value of \n\\max(d)\n. Therefore, all other values in \nd\n will be counted \n0\n times in the final answer. This means, because we want to minimise the final answer, for each \ni\n, it is always better to put the larger value out of \na_i\n and \nb_i\n in \nd\n as it will cause the value that is not being counted in the final answer to be larger.\nUsing every observation above, in order to get the minimum possible perimeter, we can do the following: \n \n Construct the arrays \nc\n and \nd\n with \nc_i\n and \nd_i\n taking their values from \na_i\n and \nb_i\n while making \nc_i\\leq d_i\n. \n The answer is \n2(c_1+c_2+\\ldots+c_n+\\max(d))\n. \nTime complexity for each test case: \nO(n)", "id": "1740B", "url": "https://codeforces.com/contest/1740/problem/B"}
{"plan": "Note that it does not make sense to move several blocks first from the left tower to the right, and then from the right to the left, since this is similar to canceling the last actions.\nUsing the fact described above and small restrictions on the input data, one of the possible solutions is the following: choose which tower will be the one where we take blocks from (try both options), iterate over the number of operations, and then check that both towers are beautiful after that number of operations.\nThere is a faster solution: move all the blocks to the left tower, and then check that there is no more than one pair of adjacent blocks of the same color. If there are no such pairs, then we can divide the tower into two in an arbitrary way, and if there is exactly one pair, then we need to make a \"cut\" exactly between two blocks of the same color. Otherwise, there will always be a pair of adjacent blocks of the same color in one of the towers.", "id": "1795A", "url": "https://codeforces.com/contest/1795/problem/A"}
{"plan": "Is \nx = k - 1\n always suitable?\nThe answer is yes, as \nx! + (x - 1)! = (x - 1)! \\times (x + 1) = ((k - 1) - 1)! \\times ((k - 1) + 1) = (k - 2)! \\times (k)\n, which is clearly a multiple of \nk\n.\nTherefore, \nx = k - 1\n is the answer.\nTime complexity: \n\\mathcal{O}(1)", "id": "1768A", "url": "https://codeforces.com/contest/1768/problem/A"}
{"plan": "Note that every ordinary number can be represented as \nd \\cdot (10^0 + 10^1 + \\ldots + 10^k)\n. Therefore, to count all ordinary numbers among the numbers from \n1\n to \n n \n, it is enough to count the number of \n(d, k)\n pairs such that \nd \\cdot (10^0 + 10^1 + \\ldots + 10^k) \\le n\n. In the given constraints, it is enough to iterate over \nd\n from \n1\n to \n9\n and \nk\n from \n0\n to \n8\n.", "id": "1520B", "url": "https://codeforces.com/contest/1520/problem/B"}
{"plan": "The problem is equivalent to finding the farthest cell from \n( x , y )\n. It is easy to see that, if they move optimally, \n( i , j )\n can reach \n( x , y )\n just by moving in an L shape, and this is equivalent to the Manhattan distance between the two points. The longest distance a prisoner will move on rows is \nmax( x - 1 , n - x )\n, and for the columns it is \n( y - 1 , m - y )\n. So answer is just \nmax( x - 1 , n - x ) + max( y - 1 , m - y )", "id": "1415A", "url": "https://codeforces.com/contest/1415/problem/A"}
{"plan": "Note that adding elements between positions \ni\n (\n1 \\le i \\le n - 1\n) and \ni + 1\n will not change the ratio of the adjacent elements, except for the ones just added. Therefore, for each pair of adjacent numbers, the problem can be solved independently.\nLet us solve the problem for a adjacent pair of numbers \na_i\n and \na_{i+1}\n for which the inequality from the statements does not hold. Suppose that \n2a_i \\le a_{i+1}\n (if not, we will swap them). Then between \na_i\n and \na_{i+1}\n it requires to insert \n\\left\\lceil log_2 \\left(\\frac{a_{i+1}}{a_i}\\right) - 1 \\right\\rceil\n elements of the form: \nIt is better not to use explicit formula, but to use the following cycle: \nwhile\n a\n[\ni\n]\n \n*\n \n2\n \n<\n a\n[\ni \n+\n \n1\n]:\n  a\n[\ni\n]\n \n*=\n \n2\n  ans \n+=\n \n1", "id": "1490A", "url": "https://codeforces.com/contest/1490/problem/A"}
{"plan": "You had to to calculate the time that each elevator would need and compare them. Let the time required by the first elevator be \nd_1 = |a - 1|\n, and the time required by the second one be \nd_2 = |b - c| + |c - 1|\n. Then the answer is \n1\n if \nd_1 < d_2\n, \n2\n if \nd_1 > d_2\n and \n3\n if \nd_1 = d_2", "id": "1729A", "url": "https://codeforces.com/contest/1729/problem/A"}
{"plan": "Let \n\\mathit{sum}\n — the initial sum in the array, \n\\mathit{cnt}_0\n — the number of even numbers, \n\\mathit{cnt}_1\n — the number of odd numbers.\nLet's see how these values ​​change with each action. In fact, we can consider four main options:\n Add an even number \nx\n to all even numbers. Then \n\\mathit{sum}\n will increase by \nx \\cdot \\mathit{cnt}_0\n, and the number of even and odd numbers will remain the same.\n Add an odd number \nx\n to all even numbers. Then \n\\mathit{sum}\n will increase by \nx \\cdot \\mathit{cnt}_0\n, the number of even numbers will become \n0\n, all numbers will become odd, so \n\\mathit{cnt}_1 = n\n.\n Add an even number \nx\n to all odd numbers. Then \n\\mathit{sum}\n will increase by \nx \\cdot \\mathit{cnt}_1\n, and the number of even and odd numbers will remain the same.\n Add an odd number \nx\n to all odd numbers. Then \n\\mathit{sum}\n will increase by \nx \\cdot \\mathit{cnt}_1\n, the number of odd numbers will become \n0\n, all numbers will become even, so \n\\mathit{cnt}_0 = n\n.", "id": "1744B", "url": "https://codeforces.com/contest/1744/problem/B"}
{"plan": "You need to implement what is written in the statement. You can either use an if-statement for each of the characters \n\\{\\texttt{c}, \\texttt{o}, \\texttt{d}, \\texttt{e}, \\texttt{f}, \\texttt{r}, \\texttt{s}\\}\n, or you can iterate through the string \n\\texttt{codeforces}\n check if the current character equals \nc\n.", "id": "1791A", "url": "https://codeforces.com/contest/1791/problem/A"}
{"plan": "We consider 2 cases. \nThe first is that the starting and ending point lie on an axis-aligned line. In this case, we simply pull the box in 1 direction, and the time needed is the distance between the 2 points as we need 1 second to decrease the distance by 1.\nThe second is that they do not lie on any axis-aligned line. Wabbit can pull the box horizontally (left or right depends on the relative values of \nx_1\n and \nx_2\n) for \n|x_1-x_2|\n seconds, take 2 seconds to move either above or below the box, then take another \n|y_1-y_2|\n seconds to move the box to \n(x_2,y_2)\n.", "id": "1428A", "url": "https://codeforces.com/contest/1428/problem/A"}
{"plan": "Every character in strings \naa\n, \naaa\n, \nbb\n and \nbbb\n has at least one character adjacent to it that is the same. So, if there is an isolated character in our string (a character that has no neighbors equal to it), we cannot build it.\nIt's easy to see that in the other case, we can build the string: we can split it into blocks of consecutive equal characters, and since there are no isolated characters, each block will have at least \n2\n characters, so it can be formed from strings of length \n2\n and/or \n3\n consisting of equal characters.\nSo, the problem is reduced to checking if each character has a neighbor equal to it.", "id": "1671A", "url": "https://codeforces.com/contest/1671/problem/A"}
{"plan": "If \nk = 0\n, the answer is \n1\n. Otherwise, consider two cases:\n The string is a palindrome (that is, \ns = rev(s)\n). Then \nrev(s) + s = s + rev(s) = s + s\n, so both operations will replace \ns\n by the string \ns+s\n, which is also a palindrome. Then for any \nk\n the answer is \n1\n.\n Otherwise \ns \\ne rev(s)\n. Then after the first operation we get either \ns + rev(s)\n (which is a palindrome) or \nrev(s) + s\n (also a palindrome). Also note that if we apply the operation to two different palindromes of length \nx\n any number of times, they cannot become equal, since they do not have the same prefix of length \nx\n. So, after the first operation from a non-palindrome 2 different strings will be obtained, and after all following operations 2 unequal strings will be obtained. So the answer is — \n2\n.", "id": "1634A", "url": "https://codeforces.com/contest/1634/problem/A"}
{"plan": "To solve the problem we need to find the character with the highest alphabetical order in our string, since Atilla will need at least that alphabet size and won't need more. To do this iterate through the string and find the character with the highest alphabetical order. Output the maximum alphabetical order found. The solution can be done in \nO(n).", "id": "1760B", "url": "https://codeforces.com/contest/1760/problem/B"}
{"plan": "If \nn\n is odd, let \nk=\\frac{n+1}{2}\n be the width of the last block. It is possible to create a square of side length \nk\n using every block as follows:\n \n \nLine \n1\n contains a \n1 \\times k\n block;\n \nLine \n2\n contains a \n1 \\times 1\n block and a \n1 \\times (k-1)\n block;\n \nLine \n3\n contains a \n1 \\times 2\n block and a \n1 \\times (k-2)\n block;\n \n\\ldots\n \nLine \ni\n contains a \n1 \\times (i-1)\n block and a \n1 \\times (k-i+1)\n block;\n \n\\ldots\n \nLine \nk\n contains a \n1 \\times (k-1)\n block and a \n1 \\times 1\n block.\n \nSince the area of this square is \nk^2\n, and the \nn+1\n-th block has a width of \nk\n tiles, the total area of the first \nn+1\n blocks is equal to \nk^2+k \\lt (k+1)^2\n. Therefore, the answer for \nn+1\n is also \nk\n.\nIn conclusion, the answer for each testcase is \n\\lfloor \\frac{n+1}{2} \\rfloor\n.\nTime complexity per testcase: \nO(1)\n.", "id": "1748A", "url": "https://codeforces.com/contest/1748/problem/A"}
{"plan": "Let's assume that the rows are numbered from \n0\n to \nn-1\n from top to bottom, and columns are numbered from \n0\n to \nm-1\n from left to right. \nIf there is no robot in the cell \n(0, 0)\n initially, we have to perform several moves up and/or left. If the first row with at least one robot is the \ni\n-th row, then we can make at most \ni\n steps up (and we should do at least \ni\n steps up, since otherwise there will me no robot in the upper row). Similarly, if the first column with at least one robot is the \nj\n-th column, then we can make at most \nj\n steps to the left (and we should do at least \nj\n steps to the left, since otherwise there will me no robot in the leftmost column).\nNow there are two possible solutions, both starting with finding \ni\n and \nj\n: we afterwards either simulate \ni\n moves up and \nj\n moves to the left and check that everything is fine, or just check that there is a robot in the cell \n(i, j)\n (since only this robot can end up in \n(0, 0)\n).", "id": "1680B", "url": "https://codeforces.com/contest/1680/problem/B"}
{"plan": "Do we really need to check all the subarrays?\nConsider a subarray \n(a_i, a_{i + 1}, \\ldots, a_{j})\n. If we add a new element \na_{j + 1}\n, when will the new subarray \n(a_i, a_{i + 1}, \\ldots, a_{j}, a_{j + 1})\n give a better result? Pause and think.\nThe minimum of the new subarray can't get better(the minimum of a smaller subarray \n\\ge\n the minimum of a larger subarray). So only when \na_{j + 1}\n is greater than the previous maximum, then it will give a better result. But in that case, do we really need to check the whole subarray to get that result? Can we get the same or a better result from a smaller subarray? Think.\nHere the maximum is \na_{j + 1}\n. So if the minimum is not \na_i\n, then the subarray \n(a_{i + 1}, a_{i + 2}, \\ldots, a_{j + 1})\n will give the same result. Otherwise, the minimum of \n(a_{i + 1}, a_{i + 2}, \\ldots, a_{j + 1})\n will not be smaller which implies that \n(a_{i + 1}, a_{i + 2}, \\ldots, a_{j + 1})\n will give a better result!\nSo if we add a new element, we don't have to check the whole subarray, checking \n(a_i, a_{i + 1}, \\ldots, a_{j})\n and \n(a_{i + 1}, a_{i + 2}, \\ldots, a_{j + 1})\n is enough.\nWhat good this observation just brought to this world? Think.\nYes, we don't have to check subarrays with length \n> 2\n, because according to the observation, \n(a_1, a_2, a_3)\n won't give a better result than \n(a_1, a_2)\n and \n(a_2, a_3)\n. And subarrays with length \n4\n won't give a better result than subarrays with length \n3\n and subarrays with length \n3\n won't give a better result than subarrays with length \n2\n. You got the idea, right? \nAnother thing to notice here is that the product of maximum and minimum of two integers is just the product of two integers. So the answer to the problem is the maximum of the products of adjacent elements in \na\n.\nTime Complexity:\n \n\\mathcal{O}(n)\n ", "id": "1554A", "url": "https://codeforces.com/contest/1554/problem/A"}
{"plan": "Notice that the answer depends only on the number of the reviewers of the third type who upvote the movie. Optimally we would want every single reviewer of the third type to upvote. We can achieve it with the following construction: send all reviewers of the first type to the first server, all reviewers of the second type to the second server and all reviewers of the third type to the first server. Since there are no downvotes on the first server, all reviewers of the third type will upvote.\nThus, the answer is the total number of reviewers of the first and the third type.\nOverall complexity: \nO(n)\n per testcase.", "id": "1511A", "url": "https://codeforces.com/contest/1511/problem/A"}
{"plan": "Note that for any rectangle size, we can always choose an \nh\n by \nw\n rectangle that contains the maximum element in the grid (which is unique). So in order for Michael to ensure that he can win, he needs to make \nh\n and \nw\n big enough such that every \nh\n by \nw\n rectangle contains the maximum element in the grid. \nLet \n(i, j)\n be the position of the maximum (1−indexed). The furthest point in the grid from it has to be one of the four corners, and hxw has to be big enough to include that furthest point and \n(i,j)\n. So just try all four corners and take the biggest rectangle that gives you. This reduces to \nmax(i, n − i + 1) \\cdot max(j, m − j + 1)\n (because the dimensions are independent).\nSo the answer is \nmax(i, n - i + 1) \\cdot max(j, m - j + 1)\n.\nComplexity: \nO(nm)", "id": "1695A", "url": "https://codeforces.com/contest/1695/problem/A"}
{"plan": "The moves are symmetrical, so we can assume that \nn≥m\n. There is no solution if \nm=1\n and \nn≥3\n, because one can only move up and down, but two consecutive down moves is required to reach \n(n, 1)\n.\nOtherwise, there is a solution. \nOne should move downwards at least \nn-1\n times, and it is forbidden to do that twice in a row, so another \nn-2\n move is necessary (\n1\n between each pair). So at least \nn-1+n-2=2 \\cdot n-3\n moves required. If \nn+m\n is even, then one more, because the parity of \na+b\n changes after every move, and the parity is even before the first and after the last move, so the total number of moves should be even.\nThere is a construction for that lower bound:\nMove alternately down and right. After reaching the \nm\n-th column, repeat the following sequence of moves: down, left, down, right. With this \n4\n move long sequence, one can move down two times. \nSo we will reach \n(n-1, m)\n, then one more move is required, or we will reach \n(n, m)\n. If we add all of these moves, we get the formula: if \nn+m\n is even then: \n2 \\cdot (m-1)+4 \\cdot (n-m)/2=2 \\cdot n-2\n,and if \nn+m\n is odd then: \n2 \\cdot (m-1)+4 \\cdot (n-m-1)/2+1=2 \\cdot n-3\n.", "id": "1668A", "url": "https://codeforces.com/contest/1668/problem/A"}
{"plan": "There should be same number of \n2\n at \na_1, a_2, \\cdots a_k\n and \na_{k+1}, \\cdots, a_n\n.\nBy checking every \nk\n, we can solve the problem at \nO(N^2)\n. By sweeping \nk\n from \n1\n to \nn-1\n, we can solve the problem in \nO(N)\n. Not counting the number of \n2\n but naively multiplying using sweeping in python was accepted since it has time complexity \nO(N^2)\n.\nChecking every \nk\n and naively multiplying solutions are \nO(N^3)\n, so those solutions won't fit in time limit.", "id": "1788A", "url": "https://codeforces.com/contest/1788/problem/A"}
{"plan": "If you have at least \nsum(a_i)\n units of energy, then the answer is \n0\n, because you can just walk to the end. Otherwise, the answer is \nsum(a_i) - m\n, because you can just sit on the first bench and then just go.\nTime complexity: \nO(n)\n.", "id": "1697A", "url": "https://codeforces.com/contest/1697/problem/A"}
{"plan": "This problem has a lot of solutions. You could even hard code all possible tests to solve it. But this problem has \nO(1)\n solution. Let the digit of \nx\n be \ndig\n. Then our character pressed each digit before \ndig\n exactly \n10\n times (\n1 + 2 + 3 + 4\n). And the amount of times he pressed the digit \ndig\n depends on the length of \nx\n. Let \nlen\n be the length of \nx\n, then the amount of times he pressed the digit \ndig\n is \n1 + 2 + \\ldots + len = \\frac{len(len + 1)}{2}\n. So the final answer is \n10 \\cdot (dig - 1) + \\frac{len(len + 1)}{2}\n.", "id": "1433A", "url": "https://codeforces.com/contest/1433/problem/A"}
{"plan": "Replace even numbers with \n0\n and odd numbers with \n1\n in the array \na\n. Now we observe that the given operation is equivalent to selecting two equal adjacent elements and deleting one of them. \nNow the array can be visualized as strips of zeros (in green) and ones (in red) like this \n[\\color{green}{0,0,0},\\color{red}{1,1,1,1},\\color{green}{0},\\color{red}{1,1}]\n. Note that since the number of adjacent elements (\na[i],a[i+1])\n such that \na[i] \\ne a[i+1]\n remains constant (nice invariant!), every strip can be handled independently. The size of every strip must be \n1\n in the final array and performing an operation reduces the size of the corresponding strip by \n1\n.\nSo, for a strip of length \nL\n, it would require \nL-1\n operations to reduce its size to \n1\n. So, every strip would contribute \n-1\n to the number of operations apart from its length. So, the answer is (\nn - \n total no. of strips) which also equals (\nn - x - 1\n) where x is number of adjacent elements (\na[i],a[i+1]\n) such that (\na[i] \\ne a[i+1]\n). ", "id": "1777A", "url": "https://codeforces.com/contest/1777/problem/A"}
{"plan": "Note, that after any of the operations, the parity of the expression \na - b\n does not change, so if the initial difference of the pair \nc - d\n is odd, then it is impossible to get this pair. Now, note that if we can get a \n(c, d)\n pair, then it can be obtained in no more than \n2\n operations. To do this, consider three cases:\n \n \nc = d = 0\n  — in this case answer is \n0\n, because initial pair is \n(0, 0)\n. \n \nc = d\n  — in this case answer is \n1\n. For this, it is enough for us to use the operation of the first type with \nk = c = d\n. \n \nc \\neq d\n  — in this case answer is \n2\n. For this we can use the operations of the first type with \nk = \\frac{c + d}{2}\n. After that, it is enough for us to use either an operation of the second type with \nk = c - \\frac{|c - d|}{2}\n if \nc > d\n, or an operation of the third type with \nk = d - \\frac{|c - d|}{2}\n otherwise. ", "id": "1556A", "url": "https://codeforces.com/contest/1556/problem/A"}
{"plan": "Note that the answer does not exceed \n2\n, because the chip can be moved as follows: \n(0, 0) \\rightarrow (x, 0) \\rightarrow (x, y)\n. Obviously, in this case, both operation are valid. It remains to check the cases when the answer is \n0\n or \n1\n. The answer is \n0\n only if the destination point is \n(0, 0)\n, and the answer is \n1\n if \n\\sqrt{x^2+y^2}\n is integer.", "id": "1657A", "url": "https://codeforces.com/contest/1657/problem/A"}
{"plan": "step by step solution\nstep 1:\n \ntask\nAssume that \na_{i} = 0\n for each \n1 \\le i \\le n\n, what should we do?\n \nsolution\nNothing! The array is already sorted and the answer is \n0\n.\nstep 2:\n \ntask\nAfter sorting the array, consider the first non-zero element of \na\n, how many elements after that are equal to zero? In other words, consider smallest \ni\n such that \na_{i} > 0\n, how many indices \nk\n exist such that \ni < k\n and \nUnable to parse markup [type=CF_MATHJAX]\n?\n \nsolution\n0, because we call an array \na\n sorted (in non-decreasing order), if for all \n1 \\le i < j \\le n\n, \na_{i} \\le a_{j}\n holds. So all numbers after leftmost non-zero element must be non-zero too.\nstep 3:\n \ntask\nassume that after sorting \na\n, \na_{i}\n (\n1 \\le i \\le n\n) is the leftmost non-zero element. Define \nG_{1}\n as the set of indices \nj\n such that \n1 \\le j < i\n and \na_{j} > 0\n at the beginning, also define \nG_{2}\n as the set of indices \nj\n such that \ni \\le j \\le n\n and \na_{j} = 0\n at the beginning. What is the answer?\n \nsolution\nmax(|G_{1}|, |G_{2}|)\n. It's obvious that in one operation at most one element will be deleted from each group. So we must perform at least \nmax(|G_{1}|, |G_{2}|)\n operations.  Now we want to show that it's sufficient too. There are three cases:\nmin(|G_{1}|, |G_{2}|) > 1\n, at this point, we know that all elements of \na\n are \n0\n or \n1\n. So we can pick one element from \nG_{1}\n and add it to an element from \nG_{2}\n, so the size of both groups will decrease by \n1\n. It's obvious that all elements of \na\n will remain less than or equal to \n1\n after this operation.\n|G_{1}| = 0\n, it's easy to see that we can add \na[k]\n (\nk \\in G_{2}\n) to a random element. So \n|G_{2}|\n will decrease by \n1\n.\n|G_{2}| = 0\n, it's easy to see that we can add \na[k]\n (\nk \\in G_{1}\n) to the last element of \na\n. So \n|G_{1}|\n will decrease by \n1\n.\nstep 4:\n \ntask\nNow how can we solve the problem using previous steps?\n \nsolution\nIf all elements are equal to \n0\n, the answer is obviously zero. Otherwise we will calculate two arrays, number of ones in each prefix and number of zeros in each suffix. We will also fix the leftmost non-zero element and calculate the answer for it easily by using Step 3 algorithm in O(n).", "id": "1746B", "url": "https://codeforces.com/contest/1746/problem/B"}
{"plan": "Let's keep an array \na\n of booleans, \na_i\n denoting whether or not some team has solved the \ni\nth problem already. Now we can iterate through the string from left to right and keep a running total \n\\mathrm{tot}\n. If \na_i\n is true (the \ni\n-th problem has already been solved), increase \n\\mathrm{tot}\n by \n1\n; otherwise, increase \n\\mathrm{tot}\n by \n2\n and set \na_i\n to true.\nThe time complexity is \n\\mathcal{O}(n)\n.\nBonus: the answer is always \nn + \\text{number of distinct characters in }s\n. Can you see why?", "id": "1703B", "url": "https://codeforces.com/contest/1703/problem/B"}
{"plan": "Let \nn = (m + 1) \\cdot q + r\n.\nNote that you need to use a promotion if \na \\cdot m \\leq b \\cdot (m + 1)\n. In this case, we will buy potatoes \nq\n times for the promotion. The remaining potatoes (or all if the promotion is unprofitable) can be bought at \n\\min(a, b)\n per kilogram.\nThen the answer is: \n \nq \\cdot \\min(a \\cdot m, b \\cdot (m + 1)) + r \\cdot \\min(a, b)\nThus this solution works in \n\\mathcal{O}(1)\n \nCode\nt \n=\n \nint\n(\ninput\n())", "id": "1793A", "url": "https://codeforces.com/contest/1793/problem/A"}
{"plan": "The answer is just \n\\min{(\\lceil {p \\over a} \\rceil \\cdot a, \\lceil {p \\over b} \\rceil \\cdot b, \\lceil {p \\over c} \\rceil \\cdot c)} - p\n.\nComplexity: \nO(1)\n.", "id": "1492A", "url": "https://codeforces.com/contest/1492/problem/A"}
{"plan": "To solve the problem, you may convert the string to lower case, strip all duplicated characters from it and compare the result to \"meow\" string.\nTo exclude duplicate characters, you can, for example, use the \nunique\n function in C++.", "id": "1800A", "url": "https://codeforces.com/contest/1800/problem/A"}
{"plan": "The problem can be solved greedily. Let \nn\n be the length of the given string. \n \n \nIf the \nn\n is even, it is always optimal for Alice to remove the whole string.\n \nIf the \nn\n is odd, it is always optimal for Alice to remove either \ns_1s_2\\ldots s_{n-1}\n or \ns_2s_3\\ldots s_n\n based on which gives the higher score and then Bob can remove the remaining character (\ns_n\n or \ns_1\n respectively). This is optimal because if Alice chooses to remove a substring of even length \n2k\n such that \n2k < n-1\n then Bob can remove the remaining \nn-2k\\geq 3\n characters, one of which will always be either \ns_1\n or \ns_n\n, thus increasing Bob's score and decreasing Alice's score.\n ", "id": "1673A", "url": "https://codeforces.com/contest/1673/problem/A"}
{"plan": "To make the arithmetic mean be equal to exactly \n1\n the sum needs to be equal to the number of elements in the array.\nLet's consider \n3\n cases for this problem:\n1) The sum of the array equals \nn\n: Here the answer is \n0\n since the arithmetic mean of the array is initially \n1\n.\n2) The sum of the array is smaller than \nn\n: The answer is always \n1\n since we can add a single integer \nk\n such that \nsum + k = n + 1\n is satisfied and more specifically \nk = n - sum + 1\n.\n3) The sum of the array is greater than \nn\n: If we add any number apart from \n0\n will add to the sum more or equal than to the number of elements. The number of \n0\n's to add can be found by a loop of adding \n0\n's until the number of elements is equal to the sum or by the simple formula of \nsum-n\n.", "id": "1537A", "url": "https://codeforces.com/contest/1537/problem/A"}
{"plan": "If \nn = 1\n, the answer is \n2\n (we can't get \n1\n, so we can move by \n3\n to the right and by \n2\n to the left). If \nn = 2\n or \nn = 3\n, the answer is obviously \n1\n. Otherwise, the answer is always \n\\lceil\\frac{n}{3}\\rceil\n. We can't get the answer less than this value (because we need at least \n\\lceil\\frac{n}{3}\\rceil\n moves to get to the point greater than or equal to \nn\n) and we can always get this answer by the recurrence.", "id": "1716A", "url": "https://codeforces.com/contest/1716/problem/A"}
{"plan": "If we do our operation on two arbitrary integers \nx \\le y\n, it is always better to copy \nx\n into \ny\n rather than to copy \ny\n into \nx\n (since a resulting pair \n(x, x + y)\n is better than \n(y, x + y)\n). \nNow, let's assume that we do our operation on two integers \nx \\le y\n such that \nx\n is not the minimum element of our array. If we replace \nx\n with minimum, we can always achieve at least the same answer. Thus, we can take any index \nm\n such that \na_m\n is the array minimum and use it to increase all other values.\nTime complexity: \nO(n)\n or \nO(nk)\n per testcase.\nSpace complexity: \nO(n)", "id": "1417A", "url": "https://codeforces.com/contest/1417/problem/A"}
{"plan": "Obviously, you can always obtain the optimal answer without using west or south moves. So the shortest path consists of \nx\n east moves and \ny\n north moves. \nLet's estimate the lower bound of the answer. Take a look at these constructions: \"\nE?E?E?E?E\n\" and \"\nN?N?N?N?N\n\" (let question mark be any command different from the used one). That's the tightest you can put east or north moves in.\nSo the answer is at least \n2 \\cdot max(x, y) - 1\n. For \nx \\neq y\n you can put them just as in the construction and fill the rest of question marks with a stay in place move. \nx = y\n case works differently, though. You can do it only in \nx + y\n moves by taking alternating moves.\nOverall complexity: \nO(1)\n per testcase.", "id": "1452A", "url": "https://codeforces.com/contest/1452/problem/A"}
{"plan": "To find the cell number in a different numbering, you can find \n(r, c)\n coordinates of the cell with the number \nx\n in the numbering \n\"by columns\"\n: \n \n \nr = ((x-1) \\mod r) + 1\n, where \na \\mod b\n is the remainder of dividing the number \na\n by the number \nb\n; \n \nc = \\left\\lceil \\frac{x}{n} \\right\\rceil\n, where \n\\left\\lceil \\frac{a}{b} \\right\\rceil\n is the division of the number \na\n to the number \nb\n rounded up. \nThen, the cell number in numbering \n\"by lines\"\n will be equal to \n(r-1)*m + c\n.", "id": "1506A", "url": "https://codeforces.com/contest/1506/problem/A"}
{"plan": "Since it does not take time to place your hand over the first letter, you need to calculate the sum of the distances between the keyboard keys corresponding to each pair of adjacent letters of the word, that is \n where \n\\mathtt{pos}(c)\n is the position of the keyboard key corresponding to the letter \nc\n.\nIn order to calculate this sum, let's just iterate through the word \ns\n with the \nfor\n loop and find the differences between the positions of \ns_i\n and \ns_{i-1}\n on the keyboard. \nTo find the position of a character on the keyboard, you could either use the built-in strings functions (such as \nstr.index\n in Python or \nstring::find\n in C++) or precalculate each letter's position on the keyboard into a separate array using another loop over a keyboard.", "id": "1607A", "url": "https://codeforces.com/contest/1607/problem/A"}
{"plan": "We can notice that the answer is the number of zeros between the leftmost occurrence of \n1\n and the rightmost occurrence of \n1\n. Why is it true? Let's take the leftmost maximum by inclusion segment of \n1\n and just shift it right. We can see that using this algorithm we will do exactly described amount of moves and there is no way improve the answer.", "id": "1433B", "url": "https://codeforces.com/contest/1433/problem/B"}
{"plan": "If \nn \\le 2\n then the answer is \n1\n. Otherwise, you can \"remove\" the first floor and then the answer is \n\\left\\lfloor\\frac{n - 3}{x}\\right\\rfloor + 2\n.", "id": "1426A", "url": "https://codeforces.com/contest/1426/problem/A"}
{"plan": "We are assuming initial sum is odd. Suppose \nf(x)(1 \\leq x \\leq 10^6)\n gives the minimum number of operations needed to change parity of \nx\n.\nIterate from \ni=1\n to \nn\n and calculate \nf(a_i)\n for each \ni\n.\nAnswer is minimum among all the calculated values.\nTime complexity is \nO(n \\cdot log(A_{max}))\n.", "id": "1762A", "url": "https://codeforces.com/contest/1762/problem/A"}
{"plan": "Strategy is quite easy: we go from \na_1\n to \na_n\n and if \na_{i - 1} + x \\le B\n we take this variant (we set \na_i = a_{i - 1} + x\n); otherwise we set \na_i = a_{i - 1} - y\n. Note that all \na_i\n are in range \n[-(x + y), B]\n so there won't be any overflow/underflow.\nIt's also not hard to prove that this strategy maximizes the sum. By contradiction: suppose the optimal answer has some index \ni\n where \na_{i - 1} + x \\le B\n but \na_i = a_{i - 1} - y\n. Let's find first position \nj \\ge i\n where \na_j = a_{j - 1} + x\n and swap operations between \ni\n and \nj\n. As a result, \nB \\ge a_i > a_{i + 1} > \\dots > a_{j}\n, all \na_i\n from \n[i, j - 1]\n were increased while \na_j\n remained the same, i. e. there is no violation of the rules and the total sum increased — contradiction.", "id": "1657B", "url": "https://codeforces.com/contest/1657/problem/B"}
{"plan": "Let's remove some index \ni\n from the first half of \ns\n and check whether the resulting string is a palindrome or not, the other half has the same approach. The prefix of length \ni-1\n already matches with the suffix of the same length because the initial string was a palindrome, so we just need to check if \nt = s[i + 1 \\ldots n - i + 1]\n is a palindrome. \nFor \nt\n to be a palindrome, \ns_{n - i + 1}\n should be equal to \ns_{i + 1}\n which was initially equal to \ns_{n - i}\n, again which should be equal to \ns_{i + 2}\n and this goes on. Here we can see that \ns_i = s_{i + 1} \\ldots = s_{n - i + 1}\n. So the answer is simply equal to the number of contiguous same characters in the center of the string which can be calculated in \n\\mathcal{O(n)}\n.", "id": "1682A", "url": "https://codeforces.com/contest/1682/problem/A"}
{"plan": "step by step solution\nstep 1:\nIt's obvious that the answer is \"NO\" if \na_{i} = 0\n for all \n1 \\le i \\le n\n.\nstep 2:\nLets prove that the answer is \"YES\" if \na_{i} = 1\n for at least one \n1 \\le i \\le n\n.\nstep 3:\nIf size of \na\n is equal to \nk\n, just use second type operation once and we are done.\nstep 4:\nOtherwise (if \n|a| > k\n), there will be three cases: (assume that \na_{j} = 1\n)\n \n \nif \nj > 2\n, you can use first type operation on first and second element and decrease size of \na\n by 1.\n \nelse if \nj < |a|-1\n, you can use first type operation on last and second to last element and decrease size of \na\n by 1.\n \nelse, it can be shown easily that \n|a| = 3\n and \nk = 2\n so you can use second type operation twice and turn \na\n into a single \n1\n.\n \nIn first and second case, you can continue decreasing size of \na\n until \n|a| = k\n (or you reach \n3\n-rd case) and you can use second type operation to reach your aim.\nstep 5:\nSo we proved that the answer is \"YES\" iff \na_{i} = 1\n for at least one \n1 \\le i \\le n\n or in other words, iff \n\\sum_{i = 1}^n a_{i} > 0\n.", "id": "1746A", "url": "https://codeforces.com/contest/1746/problem/A"}
{"plan": "You should implement what is written in the statement. Here are three ways to do it: \n \n Check that the first character is \n\\texttt{Y}\n or \n\\texttt{y}\n, check that the second character is \n\\texttt{E}\n or \n\\texttt{e}\n, and check the third character is \n\\texttt{S}\n or \n\\texttt{s}\n. \n Make an array storing all acceptable strings (there are only \n8\n), and loop and see if any of the strings match the input. \n Use some built-in function like \ntolower()\n in C++ to make the string all lowercase, and check if \ns\n is equal to \n\\texttt{yes}\n. \n The complexity is \n\\mathcal{O}(1)\n per test case.", "id": "1703A", "url": "https://codeforces.com/contest/1703/problem/A"}
{"plan": "Note that on the \ni\n-th step, Alice takes \ni\n cards from the deck. It means that after \nk\n steps, \n\\frac{k(k + 1)}{2}\n steps are taken from the deck. Thus, after \nO(\\sqrt{n})\n steps, the deck is empty. We can simulate the steps one by one by taking care of whose turn it is and what is the color of the top card. Using this information, we can keep track of how many cards of what color each player has. Print this information in the end.", "id": "1786A2", "url": "https://codeforces.com/contest/1786/problem/A2"}
{"plan": "Let's consider the 1-D problem of this problem: there are \nn\n cells, lying in a row. The robot is at the \nx\n-th cell, and the dirty cell is at the \ny\n-th cell. Each second, the robot cleans the cell at its position. The robot initially moves by 1 cell to the right each second. If there is no cell in the movement direction, its direction will be reflected. What is the minimum time for the robot to clean the dirty cell?\nThere are two cases needed to be considered: \n \n If \nx \\le y\n, then the answer is \ny - x\n. The robot just goes straight to the dirty cell. \n Otherwise, if \nx > y\n, then the robot needs to go to the right endpoint first, and then go back to the dirty cell. Going to the right endpoint takes \nn - x\n seconds, and going from that cell to the dirty cell takes \nn - y\n seconds. Therefore, the answer for this case is \n2 \\cdot n - x - y\n. \nGoing back to our original problem, we can solve it by dividing it into two 1-D versions. This is done by projecting the position of the robot and the dirty cell onto the \nOx\n and \nOy\n axis as follows.\n \n \nBy doing so, we can see that we can clean the dirty cell, if and only if one of the projections of the robot can reach the dirty cell. Therefore, the answer is the minimum between the answers of the two sub-problems.", "id": "1623A", "url": "https://codeforces.com/contest/1623/problem/A"}
{"plan": "Ideally, we would want the fixedness values to be \nn, n - 1, n - 2, \\dots, 0\n. That would make a chain of length \nn + 1\n.\nHowever, it's impossible to have fixedness of \nn - 1\n after one swap. The first swap always makes a permutation with fixedness \nn - 2\n.\nOkay, how about \nn, n - 2, n - 3, \\dots, 0\n then? That turns out to always be achievable.\nFor example, swap elements \n1\n and \n2\n, then elements \n2\n and \n3\n, then \n3\n and \n4\n and so on.\nOverall complexity: \nO(n^2)\n per testcase.", "id": "1716B", "url": "https://codeforces.com/contest/1716/problem/B"}
{"plan": "If for some hero \ni\n, no other hero is weaker than \ni\n, then the \ni\n-th hero cannot win any fights and is not a possible winner. Otherwise, the hero \ni\n is a possible winner — he may fight the weakest hero \n100^{500}\n times and be declared the winner.\nSo the solution to the problem is calculating the number of minimum elements in the array \na\n, since all other elements denote possible winners of the tournament.", "id": "1487A", "url": "https://codeforces.com/contest/1487/problem/A"}
{"plan": "The simplest solution — go through the problem, because of which the teacher might have suspicions. Now you can find the first day when Polycarp solved this problem and the last such day. Between these two days, all problems should be the same. If this is not the case, the answer is \"\nNO\n\".", "id": "1520A", "url": "https://codeforces.com/contest/1520/problem/A"}
{"plan": "At first glance, it seems like a graph problem. And indeed, this problem can be solved by explicitly building a graph considering cells as the vertices and checking that there is a safe path from start to finish via DFS/BFS/DSU/any other graph algorithm or data structure you know. But there's a much simpler solution.\nSince there are only two rows in a matrix, it's possible to move from any cell in the column \ni\n to any cell in column \ni + 1\n (if they are both safe, of course). It means that as long as there is at least one safe cell in each column, it is possible to reach any column of the matrix (and the cell \n(2, n)\n as well).\nIt's easy to see that if this condition is not met, there exists a column with two unsafe cells — and this also means that this column and columns to the right of it are unreachable. So, the problem is reduced to checking if there is a column without any unsafe cells. To implement this, you can read both rows of the matrix as strings (let these strings be \ns_1\n and \ns_2\n) and check that there is a position \ni\n such that both \ns_1[i]\n and \ns_2[i]\n are equal to \n1\n.", "id": "1598A", "url": "https://codeforces.com/contest/1598/problem/A"}
{"plan": "Let's turn the problem around: we'll look for the longest suffix that will make Polycarp happy, since it's the same thing.\nLet's create an array \ncnt\n, in which we will mark the numbers already encountered. Let's go along \na\n from right to left and check if \na_i\n does not occur to the right (in this case it is marked in \ncnt\n), if it occurs to the right, then removing any prefix that does not include \ni\n, we get an array where \na_i\n occurs twice, so we have to delete prefix of length \ni\n.", "id": "1714B", "url": "https://codeforces.com/contest/1714/problem/B"}
{"plan": "For positions which numbers are the same, they cannot be colored using same color.\nLet us color the \ni\n-th occurrence of any number using color \ni\n.\nWe can see that: \n \n We cannot use fewer colors: if there are \nk\n occurrence of any number, at least \nk\n color is needed. \n The assignment of color is valid: Since the sequence was non-increasing, for any subsequence it is also non-increasing. As there are no duplicates in colored subsequence, the subsequence is strictly increasing as well. \nTherefore, we only need to count the number of occurrence of every number and take the maximum of them.\nTime complexity: \nO(n)\n per test case", "id": "1478A", "url": "https://codeforces.com/contest/1478/problem/A"}
{"plan": "The idea is as follows: we will go from the end of the string \nt\n and get the original string \ns\n.\nNote that if the current digit is \n0\n, then a letter with a two-digit number has been encoded. Then we take a substring of length three from the end, discard \n0\n and get the number of the original letter.\nOtherwise, the current number \n\\neq 0\n, then a letter with a one-digit number was encoded. We easily reconstruct the original letter.\nNext, discard the already processed characters and repeat the process until the encoded string is complete.", "id": "1729B", "url": "https://codeforces.com/contest/1729/problem/B"}
{"plan": "It's enough to sort \na\n in non-decreasing order and sort \nb\n in non-increasing order and check, whether \na_i + b_i \\leq x\n for all \ni\n.\nCorrectness can be proven by induction: let's show that if answer exists, there is a solution with minimum in \na\n and maximum in \nb\n are paired. Let \nm_a\n be minimum in \na\n and \nm_b\n be maximum in \nb\n. Let \np\n be number paired with \nm_a\n and \nq\n be number paired with \nm_b\n. Since solution is correct, \nm_a + p \\leq x\n and \nm_b + q \\leq x\n. Since \nm_a \\leq q\n, \nm_a + m_b \\leq x\n. Since \np \\leq m_b\n, \np + q \\leq x\n. So, \nm_a\n can be paired with \nm_b\n.", "id": "1445A", "url": "https://codeforces.com/contest/1445/problem/A"}
{"plan": "We can keep track of our current point \n(x,y)\n as we iterate over the string: \n \n if \ns_i = \\texttt{L}\n, then decrement \nx\n (set \nx \\leftarrow x-1\n); \n if \ns_i = \\texttt{R}\n, then increment \nx\n (set \nx \\leftarrow x+1\n); \n if \ns_i = \\texttt{U}\n, then increment \ny\n (set \ny \\leftarrow y+1\n); \n if \ns_i = \\texttt{D}\n, then decrement \ny\n (set \ny \\leftarrow y-1\n). \n Initially, set \nx=y=0\n. If \nx=y=1\n is ever true, then we should output \nYES\n; otherwise, we output \nNO\n.\nThe time complexity is \n\\mathcal{O}(n)\n.", "id": "1791B", "url": "https://codeforces.com/contest/1791/problem/B"}
{"plan": "Let's note that if \na_i = a_j\n, then \ns_i\n must be equal to \ns_j\n, since we must change the same value to the same letter. If we check this for all pairs of \ni\n and \nj\n and find no such contradictions, then the answer is \"\nYES\n\", otherwise \"\nNO\n\".\nWe got the solution for \nO(n^2)\n for one test case.", "id": "1744A", "url": "https://codeforces.com/contest/1744/problem/A"}
{"plan": "If there is no grass on the field, the answer is \n0\n. If the whole field is filled with grass, the answer is \n2\n, because there always will be one cell that we can't clear with one move. Otherwise, the answer is \n1\n. This is because if the cell \n(i, j)\n is empty, we can just choose other row than \ni\n and other column than \nj\n and clear three other cells in one move.", "id": "1701A", "url": "https://codeforces.com/contest/1701/problem/A"}
{"plan": "Suppose the values of \na_1\n, \na_2\n, \na_3\n, \na_4\n are sorted in non-descending order. Then the shorter side of the rectangle cannot be longer than \na_1\n, because one of the sides must be formed by a segment of length \na_1\n. Similarly, the longer side of the rectangle cannot be longer than \na_3\n, because there should be at least two segments with length not less than the length of the longer side. So, the answer cannot be greater than \na_1 \\cdot a_3\n.\nIt's easy to construct the rectangle with exactly this area by drawing the following segments:\n \n from \n(0, 0)\n to \n(a_1, 0)\n; \n from \n(0, a_3)\n to \n(a_2, a_3)\n; \n from \n(0, 0)\n to \n(0, a_3)\n; \n from \n(a_1, 0)\n to \n(a_1, a_4)\n. \nSo, the solution is to sort the sequence \n[a_1, a_2, a_3, a_4]\n, and then print \na_1 \\cdot a_3\n.", "id": "1468E", "url": "https://codeforces.com/contest/1468/problem/E"}
{"plan": "Here are two ways to implement what's given in the problem:\n \n Take input as an array \n[a_1, a_2, a_3]\n, and sort it. Output the middle element. \n Write two if-statements. The first: if \n(a>b \\text{ and } a<c) \\text{ or } (a<b \\text{ and } a>c)\n, output \na\n. Else, if \n(b>a \\text{ and } b<c) \\text{ or } (b<a \\text{ and } b>c)\n, output \nb\n. Else, output \nc\n. ", "id": "1760A", "url": "https://codeforces.com/contest/1760/problem/A"}
{"plan": "Firstly, since we are interested in minimum possible size of the array, we don't need any elements other than minimums and maximums. So, the array has at most \n2\n distinct elements.\nNow there are many possible solutions. The simplest one is to iterate on the number of minimums (let this be \ni\n) and maximums (let this be \nj\n). If the number of minimums is equal to the number of maximums, then the array should have all elements as both its minimums and maximums, so its length should be \ni\n; otherwise, it should be \ni + j\n. We can iterate on all possible pairs \n(i, j)\n and find the best result over all of them.\nA solution in \nO(1)\n is possible if you see that you only have to consider \nl_1\n and \nl_2\n as the number of minimums/maximums, or check if the segments \n[l_1, r_1]\n and \n[l_2, r_2]\n intersect in \nO(1)\n.", "id": "1680A", "url": "https://codeforces.com/contest/1680/problem/A"}
{"plan": "Let \np_i\n be the first element such that \np_i \\neq i\n. For the prefix of elements \np_1=1,p_2=2, \\dots ,p_{i-1}=i-1\n we do not need to change anything because it is already the minimum lexicographic, but we would like to have \ni\n instead of \np_i\n on that position. The solution is to reverse segment \n[i,j]\n, where \np_j=i\n.\nNotice that \ni<j\n since \np_k=k\n for every \nk<i\n, so \np_k<p_j=i\n for every \nk<i\n.\nTime complexity: \nO(n)\n.", "id": "1638A", "url": "https://codeforces.com/contest/1638/problem/A"}
{"plan": "Assume a permutation \np\n, and \n\\sum_{i=2}^{2n}[p_{i-1}<p_i]=k\n. Assume a permutaion \nq\n, satisfying \n\\forall 1 \\leqslant i \\leqslant 2n, q_i=2n-p_i\n. We can know that \n\\forall 2 \\leqslant i \\leqslant 2n,[p_{i-1}<p_i]+[q_{i-1}<q_i]=1\n. Thus,\n\\sum_{i=2}^{2n}[q_{i-1}<q_i]=2n-1-k\n, and either \np\n should be counted or \nq\n should be counted. All in all, the half of all the permutaions would be counted in the answer. Thus, the answer is \n\\frac{1}{2}(2n)!\n. The time complexity is \nO(\\sum n)\n. If you precalulate the factors, then the complexity will be \nO(t+n)\n.", "id": "1581A", "url": "https://codeforces.com/contest/1581/problem/A"}
{"plan": "\\rightarrow\n Applying the operation on \na_1\n and \na_3\n (irrespective of which element is incremented and which one is decremented) does not change the value of \na_1 + a_3 - 2 \\cdot a_2\n.\n\\rightarrow\n Incrementing \na_1\n (or \na_3\n) by \n1\n and decrementing \na_2\n by \n1\n causes the value of \na_1 + a_3 - 2 \\cdot a_2\n to increase by \n3\n.\n\\rightarrow\n Decrementing \na_1\n (or \na_3\n) by \n1\n and incrementing \na_2\n by \n1\n causes the value of \na_1 + a_3 - 2 \\cdot a_2\n to decrease by \n3\n.\nThis effectively means that we can add or subtract any multiple of \n3\n by performing some number of operations. Also, the value of \na_1 + a_3 - 2 \\cdot a_2\n will never change modulo \n3\n. Thus,\n \n If \n\\, \\, a_1 + a_3 - 2 \\cdot a_2 \\equiv 0\n \n\\mod 3\n, then the minimum value of \nd(a_1, a_2, a_3) = |0| = 0\n \n If \n\\, \\, a_1 + a_3 - 2 \\cdot a_2 \\equiv 1\n \n\\mod 3\n, then the minimum value of \nd(a_1, a_2, a_3) = |1| = 1\n \n If \n\\, \\, a_1 + a_3 - 2 \\cdot a_2 \\equiv 2\n \n\\mod 3\n, then the minimum value of \nd(a_1, a_2, a_3) = |2-3| = |-1| = 1\n \nIn simpler words, if \na_1 + a_3 - 2 \\cdot a_2\n is divisible by \n3\n the answer is \n0\n, otherwise it is \n1\n.\nTime Complexity\n: \n\\mathcal{O}(1)", "id": "1605A", "url": "https://codeforces.com/contest/1605/problem/A"}
{"plan": "Iterating through array and looking on our element and previous element, there is possible 4 variants: \n \n \na_i == 1\n and \na_{i - 1} == 1\n — k += 5 \n \na_i == 1\n and \na_{i - 1} == 0\n — k += 1 \n \na_i == 0\n and \na_{i - 1} == 1\n — k += 0 \n \na_i == 0\n and \na_{i - 1} == 0\n — k = -1, break ", "id": "1585A", "url": "https://codeforces.com/contest/1585/problem/A"}
{"plan": "Let \nk\n be the length of \nn\n. Let \nn_i\n be the \ni\n-th digit of \nn\n (\n1\n-indexation from the left).\n \n \nk = 1\nThe game ends immediately so the answer is \nn\n itself. \n \nk = 2\nAlice should make the first move and she has to swap \nn_1\n and \nn_2\n. After that Bob removes \nn_1\n and in the end there is only \nn_2\n. \n \nk \\ge 3\nAlice can make swaps in such way that when there are only two digits left the second digit will be the maximal digit of \nn\n. Then she will make a swap and the maximal digit will be on the first position. The other one will be removed by Bob. This way she can always get the maximal digit of \nn\n in the end of the game. ", "id": "1684A", "url": "https://codeforces.com/contest/1684/problem/A"}
{"plan": "Note, that posts will be removed in the order \nn, n - 1, \\ldots, 1\n.\nThe post \nn - k + 1\n will be removed at the first time, when there are at least \nk\n different numbers among \np_1, p_2, \\ldots, p_i\n.\nSo let's calculate the number of different numbers among \np_1, p_2, \\ldots, p_i\n for each \ni\n using boolean array of length \nm\n iterating \ni\n from \n1\n to \nm\n. Using them we can calculate the answer.\nTime complexity: \nO(n + m)\n.", "id": "1799A", "url": "https://codeforces.com/contest/1799/problem/A"}
{"plan": "There are some solutions based on case analysis, but in my opinion, the most elegant one is the following:\nLet's pick a color with the maximum possible number of pixels and repaint all other pixels into it. We will try to pick all pixels of some other color and repaint them in one operation, and we can ignore the constraint that we can repaint no more than \n2\n pixels, since we will never need to repaint \n3\n or \n4\n pixels in one operation. So, the number of operations is just the number of colors other than the one we chosen, or just \nd - 1\n, where \nd\n is the number of different colors in the image. To calculate this, we can use a set or an array of size \n26\n, where we mark which colors are present.", "id": "1721A", "url": "https://codeforces.com/contest/1721/problem/A"}
{"plan": "Therefore, for the input \nn\n, we can simply check which one of \nn\n, \nn+1\n, and \nn+2\n has its gcd-sum \n> 1\n, and print the lowest of them.", "id": "1498A", "url": "https://codeforces.com/contest/1498/problem/A"}
{"plan": "Note that it is enough to consider the string \nfull = \nYesYes...Yes\n, where \nYes\n is written \n18\n times, since \n18 \\cdot 3 = 54\n, and our substring \ns\n has size \n|s| \\le 50\n.\nThen we just use the built-in function \nfind\n to find out if our string \ns\n is a substring of the string \nfull\n.", "id": "1759A", "url": "https://codeforces.com/contest/1759/problem/A"}
{"plan": "For the \nGCD\n of the whole array to be greater than \n1\n, each of the elements must have a common prime factor, so we need to find the prime factor that's the most common in the array and merge the elements that have this prime factor with those who don't, the answer being the size of the array - number of occurrences of the most frequent prime factor. And, because the numbers are consecutive, the most common prime factor is always \n2\n. So, the minimum number of moves we need to do is the count of odd numbers in the given range, which is \n(r - l + 1) - (r / 2 - (l - 1) / 2)\n. Now. the answer is \"\nYES\n\" when the minimum number of moves we need to do is less than or equal to \nk\n and \"\nNO\n\" otherwise. \nThe extra cases we should take care of are the ones where \nl = r\n, in which the answer is always \"\nYES\n\", or \"\nNO\n' only when \nl = r = 1\n.", "id": "1629B", "url": "https://codeforces.com/contest/1629/problem/B"}
{"plan": "The necessary and sufficient condition is the following: for each color the key should appear before the door.\nNecessary is easy to show: if there is a key after a door, this door can't be opened.\nSufficient can be shown the following way. If there are no closed doors left, the knight has reached the princess. Otherwise, consider the first door the knight encounters. He has a key for this door, so he opens it. We remove both the key and the door from the string and proceed to the case with one less door.\nOverall complexity: \nO(1)\n.", "id": "1644A", "url": "https://codeforces.com/contest/1644/problem/A"}
{"plan": "Hint 1: You can think of this problem as 2 independent 1D questions (one is up and down , and the other is left and right) instead of 1 2D question.\nHint 2: For each 1D part what is the interval of positions that you can reach and see if the end point is in this interval.\nHint 3: The interval of up and down is [-The count of D , The count of U] and the interval of left and right is [-The count of L , The count of R].", "id": "1481A", "url": "https://codeforces.com/contest/1481/problem/A"}
{"plan": "This is a simple implementation problem. Let's calculate two values for each \ni\n from \n1\n to \nn\n: \ncnt_i\n — the number of occurrences of \ni\n in \na\n and \nidx_i\n — any position of \ni\n in \na\n.\nThen, let's iterate through \ni\n from \n1\n to \nn\n and, if \ncnt_i = 1\n, just print \nidx_i\n (because if it is the only such element then we found the winner). If we didn't find any such element, we have to print \n-1\n.", "id": "1454B", "url": "https://codeforces.com/contest/1454/problem/B"}
{"plan": "Suppose the first skill to be performed is fixed. Then it is optimal to use the following greedy strategy. \n \n If possible, perform a skill of a different type from the last skill. If there are multiple skills of a different type from the last skill, choose the one with the largest initial damage. \nInspired by the above observation, if the type of the first skill is fixed, it is optimal to choose the one with the smallest initial damage. This is because the first skill will be never doubled. \nTherefore, we have the following algorithm. \n \n Try each possible type \na\n (of the first skill). \n Remove the skill of type \na\n with the smallest intial damage. \n Alternate the types of the following skills as much as possible. \nThis algorithm is sufficient to pass this problem. Nevertheless, a slightly more elegant analysis will give a simpler solution. \n \n If the number of skills of type fire is equal to that of skills of type frost, double the damage of all skills except for the one with the smallest initial damage. \n Otherwise, let \nk\n be the smaller number of skills of either type, then double the damage of the largest \nk\n skills of both types. \nThe time complexity is \nO(n \\log n)\n due to sortings.", "id": "1738A", "url": "https://codeforces.com/contest/1738/problem/A"}
{"plan": "The key insight is that due to the fact that there is only one row of enemy pawns, and those pawns never move, there are only \n3\n possible columns where one of Gregor's pawns can end up in.\nWe can solve this problem greedily, going from column \n1\n to column \nN\n. At the current column \nj\n, if Gregor has a pawn in this column, then we greedily consider 3 cases. \n \n \nIf there is an uncaptured enemy pawn in column \nj-1\n, mark that pawn as captured and increment the answer. Column \nj-1\n will never be looked at again, so this decision is optimal.\n \nIf there is no pawn in column \nj\n, just move Gregor's pawn forward, and increment the answer.\n \nIf there is an uncaptured enemy pawn in column \nj+1\n, mark that pawn as captured and increment the answer.\n \nOtherwise, this pawn will not reach the first row.\n \nThis greedy solution is guaranteed to produce the maximum possible answer.\nThe time complexity is \n\\mathcal{O}(N)\n.", "id": "1549B", "url": "https://codeforces.com/contest/1549/problem/B"}
{"plan": "Let's perform the process in reverse: we will remove the first and last character of the string, if these two characters are different. We should do this as long as possible, since we need to find the shortest initial string. \nSo the algorithm is straightfoward: keep track of the left and right characters, and if they are different, remove both. Otherwise, output the length of the current string (or output \n0\n if the string became empty).\nThere are a few ways to implement this. For example, you can keep two pointers, one at the beginning of the string and one at the end, say, \nl=1\n and \nr=n\n, and check if \ns_l=s_r\n. If it's true, then we increment \nl\n and decrement \nr\n. Otherwise, we output \nr-l+1\n. We stop when \nl \\geq r\n.\nAlternatively, you can use deque to simulate the operations directly. The time complexity is \n\\mathcal{O}(n)\n.", "id": "1791C", "url": "https://codeforces.com/contest/1791/problem/C"}
{"plan": "If Vasya has \nb\n coins of \n2\n burles, then he can collect amounts of \n2, 4, \\dots, 2 * b\n burls. If Vasya does not have \n1\n burles coins, then he cannot collect the amount of \n1\n burle. If he has at least one coin in \n1\n burl, he can score odd amounts up to \n2*b + a\n. The following \n1\nburl coins increase the maximum amount he can make. If Vasya has \na\n coins for \n1\n burle, he can make up the amount of \n2 * b + a\n burles, and \n2 * b + a + 1\n - not anymore.", "id": "1660A", "url": "https://codeforces.com/contest/1660/problem/A"}
{"plan": "The described sorting algorithm is similar to \nOdd-even sort\n.\nIn this problem, it's enough to carefully implement the process described in the problem statement. Here is one sample implementation in C++:\n#include\n \n<\nbits\n/\nstdc\n++.\nh\n>\nusing\n \nnamespace\n std\n;\nint\n main\n()\n \n{\n  \nint\n tt\n;\n  cin \n>>\n tt\n;\n  \nwhile\n \n(\ntt\n–)\n \n{\n    \nint\n n\n;\n    cin \n>>\n n\n;\n    vector\n<int>\n a\n(\nn\n);\n    \nfor\n \n(\nint\n i \n=\n \n0\n;\n i \n<\n n\n;\n i\n++)\n \n{\n      cin \n>>\n a\n[\ni\n];\n    \n}\n    \nint\n ans \n=\n \n0\n;\n    \nwhile\n \n(!\nis_sorted\n(\na\n.\nbegin\n(),\n a\n.\nend\n()))\n \n{\n      \nfor\n \n(\nint\n i \n=\n ans \n%\n \n2\n;\n i \n+\n \n1\n \n<\n n\n;\n i \n+=\n \n2\n)\n \n{\n        \nif\n \n(\na\n[\ni\n]\n \n>\n a\n[\ni \n+\n \n1\n])\n \n{\n          swap\n(\na\n[\ni\n],\n a\n[\ni \n+\n \n1\n]);\n        \n}\n      \n}\n      ans \n+=\n \n1\n;\n    \n}\n    cout \n<<\n ans \n<<\n endl\n;\n  \n}\n  \nreturn\n \n0\n;\n}\nTo estimate the complexity of this solution, we need to know the maximum number of iterations required to sort a permutation of length \nn\n. It turns out that this number is equal to exactly \nn\n, thus the complexity of the algorithm is \nO(n^2)\n. This is intuitive because the algorithm looks similar to bubble sort that requires \nn\n iterations too, or you can directly check that sorting \n[n, n-1, \\ldots, 1]\n requires \nn\n iterations and reason that \"more sorted\" sequences can't require more iterations than \"less sorted\" sequences, and \n[n, n-1, \\ldots, 1]\n is naturally the \"least sorted\" sequence of them all. For a formal proof see e.g. the linked \nWikipedia page\n. The proof also follows from the editorial of problem F in Div. 1. If you have a simpler proof, please share in comments!", "id": "1561A", "url": "https://codeforces.com/contest/1561/problem/A"}
{"plan": "Let's use the greedy solution: we will go through the digits in decreasing order. If the sum of \ns\n we need to dial is greater than the current digit, we add the current digit to the end of the line with the answer. \nNote that in this way we will always get an answer consisting of the minimum possible number of digits, because we are going through the digits in descending order. \nSuppose that the resulting number is not optimal. Then some digit can be reduced, and some digit that comes after it can be increased, in order to save the sum (we can not increase the digit before it, as then we get a number greater than the current one). Two variants are possible. \n \n We want to increase the digit \nx\n to \nx+1\n, but then it becomes equal to the digit following it, or exceeds the value \n9\n. Then we can't increment that digit. \n Otherwise, in the first step, we can get \nx+1\n instead of \nx\n, but since we are going through the digits in decreasing order, we cannot get the value of \nx\n in that case. Contradiction. ", "id": "1714C", "url": "https://codeforces.com/contest/1714/problem/C"}
{"plan": "Without loss of generality, let's say \nr \\le b\n (otherwise, we can swap them). Note that you can't use more than \nr\n packets (at least one red bean in each packet), so \nb\n can't exceed \nr \\cdot (d + 1)\n (at most \nd + 1\n blue beans in each packet).\nSo, if \nb > r \\cdot (d + 1)\n then asnwer is \nNO\n. Otherwise, we can form exactly \nr\n packets.", "id": "1519A", "url": "https://codeforces.com/contest/1519/problem/A"}
{"plan": "Let \ng(x)\n be the maximum integer satisfying \n2^{g(x)}|x\n.\nA greedy solution is to make one integer odd integer, and plus it to other even integers. Let \nf(a)\n be the answer of an sequence \n{a_n}\n.\nWe can find that:\n \nf(a)=\\begin{cases}\\sum[g (a_i)>0]-1+\\min\\{g(a_i)\\}& \\forall i,\\ g(a_i)>0 \\\\\\sum[g (a_i)>0]&\\texttt{otherwise}\\end{cases}=\\sum[g (a_i)>0]+\\max\\{0,\\min\\{g(a_i)\\}-1\\}\nIt can be shown that it is the optimal strategy.\nWe can prove that \nf(a)\n decreases by at most \n1\n with one operation. \n \n \nFor the first operation, assuming we choose \na_i\n and \na_j\n, let \na_k=a_i+a_j\n. Obviously \ng(a_k)\\geq \\min{g(a_i),g(a_i)}\n holds, so \n\\sum[g (a_i)>0]\n decreases by at most \n1\n, and \n\\min{g(a_i)}\n does not decrease. So \nf(a)\n decreases by at most \n1\n.\n \nFor the second operation, assuming we choose \na_j\n. If \ng(a_j)=\\min{g(a_i)}>1\n, \n\\max{0,\\min{g(a_i)}-1}\n decreases by \n1\n and \n\\sum[g (a_i)>0]\n remains unchanged. Otherwise \n\\max{0,\\min{g(a_i)}-1}\n does not change and \n\\sum[g (a_i)>0]\n decreases by at most \n1\n. So \nf(a)\n decreases by at most \n1\n.\n \nWe can draw a conclusion that \nf(a)\n decreases by at most \n1\n after one operation. Since \nf(a)=0\\Leftrightarrow \n \na_i\n are odd integers, the strategy is proved to be optimal.\nThe time complexity is \nO(n)\n.", "id": "1688B", "url": "https://codeforces.com/contest/1688/problem/B"}
{"plan": "We have a very explicit description of whether the arrangement is possible. Sort the heights so that \nh_1 \\leq h_2 \\leq \\dots \\leq h_{2n}\n. Then, there exists such arrangement if and only if all the following conditions hold.\n \n\\begin{align*} h_{n+1}-h_1 &\\geq x \\\\ h_{n+2}-h_2 &\\geq x \\\\ &\\vdots \\\\ h_{2n}-h_n &\\geq x \\end{align*}\nWe present two proofs.\n \nProof 1 (Direct Proof).\n Suppose that the arrangement is possible. We will show that for each \ni\n, we have \nh_{n+i}-h_i\\geq x\n.\nTo do so, note that \nn+1\n people who have height in \n[h_i, h_{n+i}]\n. It's impossible that these \nn+1\n people got assigned to different columns (because there are \nn\n columns), so there exist two people that got assigned to the same column. \nHowever, because these two people have height in \n[h_i, h_{n+i}]\n, the difference in heights between these two people is at most \nh_{n+i}-h_i\n. As the difference is at least \nx\n by the arrangement, we must have that \nh_{n+i}-h_i\\geq x\n. \n\\blacksquare\n \nProof 2 (Exchange Argument).\n First, we look at two pairs. Suppose that the \ni\n-th person in the first and second row have heights \na < b\n, while the \nj\n-th person in the first and second row have heights \nc < d\n. \n \n\\begin{array}{ccccc} \\dots & a & \\dots & c & \\dots \\\\ \\dots & b & \\dots & d & \\dots \\end{array}\n \n \nAssume that \nb\\geq c\n, then we switch \nb,c\n. The arrangement still works since \na-c \\geq a-b \\geq x\n and \nb-d \\geq c-d \\geq x\n.\n \nSimilarly, \na\\geq d\n yields a switch.\n \nThus, we can keep exchanging until anyone in the first row is at least as tall as anyone in the second row. Thus, the first row must be \nh_{n+1}, h_{n+2}, \\dots, h_{2n}\n, while the second row must be \nh_1, h_2, \\dots, h_n\n in some order.\nNow, we look at the same picture again. Assume that \na\\geq c\n but \nb\\leq d\n. then, we can switch \nb,d\n, and it still works because \na-d \\geq c-d \\geq x\n and \nc-b \\geq c-d \\geq x\n. Thus, we can switch the second row until it matches the order of the first row.\nTherefore, we force the first row to be \nh_{n+1}, h_{n+2}, \\dots, h_{2n}\n, while the second row must be \nh_1, h_2, \\dots, h_n\n in that order. This implies the conclusion. \n\\blacksquare\n \nTime Complexity: \nO(n\\log n)\n for sorting.", "id": "1705A", "url": "https://codeforces.com/contest/1705/problem/A"}
{"plan": "Notice that it's never optimal to erase a subsequence of length greater than \n2\n because every RBS of length above \n2\n contains an RBS of length \n2\n inside and removing it won't break the regular property of the outside one.\nSo the task can be solved for the round and the square brackets independently, the answer will be the sum of both. Let's solve the version for brackets '\n(\n' and '\n)\n'. In general, you just want to remove consecutive substring \"\n()\n\" until there is no more left in the string. That can be done by processing the string from left and right and maintaining a stack of current brackets. If the top bracket in it is '\n(\n' and the current bracket is '\n)\n', then you can increment the answer and remove that bracket from the stack. Otherwise, you push the current bracket to the stack.\nOverall complexity: \nO(|s|)\n per testcase.", "id": "1452C", "url": "https://codeforces.com/contest/1452/problem/C"}
{"plan": "You only need to write an if statement and check if any of these are true: \na+b=c\n, \nb+c=a\n, \nc+a=b\n.", "id": "1742A", "url": "https://codeforces.com/contest/1742/problem/A"}
{"plan": "Note that bending the cable on the wall is not necessary: we can always bend it on the floor and on the ceiling, while keeping the vertical part of the cable straight. Thus, we can just disregard the height of the room, view the problem as two-dimensional, and add \nh\n to the answer at the end.\nIn the two-dimensional formulation, we need to connect points \n(a, b)\n and \n(f, g)\n with a cable that goes parallel to the coordinate axes and touches at least one side of the \n(0, 0)\n — \n(w, d)\n rectangle. We can now casework on the side of the rectangle (the sides are referred to as in the picture from the problem statement): \n \n If the cable touches the front side, its length will be \nb + |a - f| + g\n. \n If the cable touches the left side, its length will be \na + |b - g| + f\n. \n If the cable touches the back side, its length will be \n(d - b) + |a - f| + (d - g)\n. \n If the cable touches the right side, its length will be \n(w - a) + |b - g| + (w - f)\n. \nOut of these four values, the smallest one (plus \nh\n) is the answer.", "id": "1782A", "url": "https://codeforces.com/contest/1782/problem/A"}
{"plan": "There are several cases to consider: \n \n If all the cell are white, then it is impossible to perform any operations, so you cannot make any cell black. The answer is \n-1\n. \n If the cell in row \nr\n and column \nc\n is already black, then we don't need to perform any operations. The answer is \n0\n. \n If any of the cells in row \nr\n are already black (that is, the cell we need to turn black shares a row with a black cell), then we can take this black cell and make row \nr\n. The same is true if any of the cells in column \nc\n are already black. The answer is \n1\n. \n Otherwise, we claim the answer is \n2\n. Take any black cell and make its row black. This means that every column contains a black cell, so now we can take column \nc\n are turn it black. Thus the answer is \n2\n. \n This can be easily implemented in \n\\mathcal{O}(nm)\n time per test case.", "id": "1627A", "url": "https://codeforces.com/contest/1627/problem/A"}
{"plan": "Obviously, the operation is, for each pair of adjacent and unequal characters, change both of them to \n0\n or \n1\n. In other words, the string is divided into many adjacent binaries with length of \n2\n. If the binary is \"01\" or \"10\", it needs \n1\n operation, otherwise the operation is not required.\nIf you want to minimize the number of \"contiguous segments\", a simple greedy way is to change each \"binary requiring operation\" (i.e. \n01\n or \n10\n) into the form of the previous or next \"binary requiring no operation\" (i.e. \n11\n or \n00\n). For example: \"0010\" change to \"0000\" and \"1101\" change to \"1111\". In this way, this \"binary requiring operation\" has no contribution to the final number of contiguous segments. We only need to count the number of contiguous \"11\" and \"00\" binaries.\nIn particular, if all binaries are \"01\" or \"10\", the final contribution to the number of final contiguous segments is \n1\n in total.", "id": "1678B1", "url": "https://codeforces.com/contest/1678/problem/B1"}
{"plan": "Let the number of elements in the sequence equal to \nn^2\n be \nx\n and let the sum of all other numbers be \nu\n. Then, \ns=x\\cdot n^2+u\n. If an element of the sequence is not equal to \nn^2\n, then its value is at most is \nn-1\n. There are \nn+1\n numbers in the sequence, so \nu\\leq (n-1)\\times (n+1)=n^2-1\n. Thus, \n\\displaystyle \\left \\lfloor \\frac{s}{n^2} \\right \\rfloor= \\left \\lfloor \\frac{x\\cdot n^2+u}{n^2} \\right \\rfloor=\\left\\lfloor x+\\frac{u}{n^2} \\right\\rfloor=x\n, which is the value we want to find. So, to solve the problem it is enough to compute the value of \n\\displaystyle \\left\\lfloor \\frac{s}{n^2} \\right\\rfloor\n.\nIntended complexity: \nO(1)\n per test case. ", "id": "1646A", "url": "https://codeforces.com/contest/1646/problem/A"}
{"plan": "Suppose that we did one operation and not all numbers are equal. Let's say that we have \nn-1\n numbers \nx\n and \n1\n number \ny\n now, with \nx \\neq y\n. \nIn the next operation, we have two options: to make operation with \nn-1\n numbers \nx\n, or with \nn-2\n of \nx\n and one \ny\n. If we go with the first option, we will still have \nn-1\n of \nx\n and one \ny\n: numbers won't change. If we go with the second option, we will have one number \nx\n and \nn-1\n numbers \n\\frac{(n-2)x + y}{n-1}\n, where \n\\frac{(n-2)x + y}{n-1} = x + \\frac{y-x}{n-1} \\neq x\n. So, we again are in a state where we have \nn-1\n copies of one number and one different number. \nSo, if after the first operation not all numbers are equal, they will never be all equal. Therefore, it's enough to check each possible operation in \nO(n^2)\n (which can be clearly optimized to \nO(n)\n).\nAnd go watch the movie Everything Everywhere All At Once, it's fantastic!", "id": "1686A", "url": "https://codeforces.com/contest/1686/problem/A"}
{"plan": "Tutorial\n1766A - Extremely Round\nThere are many ways to solve this problem.\nThe most naive one (iterating through all numbers from \n1\n to \nn\n in each test case and checking if they are extremely round) fails, since it is \nO(tn)\n, but you can optimize it by noticing that extremely round numbers are rare. So, for example, we can iterate through all numbers from \n1\n to \n999999\n once, remember which ones are extremely round, store them into an array, and while answering the test case, only check the numbers from the array we have created.\nThere is also a solution in \nO(1)\n per test case with a formula, try to invent it yourself.", "id": "1766A", "url": "https://codeforces.com/contest/1766/problem/A"}
{"plan": "It is easy to see, in a beautiful picture, there must be at least \n2\n female cosplayers between \n2\n consecutive male cosplayers. It is also the sufficient condition, as if there are \nx\n male cosplayers in a subsegment, there are at least \n2(x - 1) = 2x - 2 \\geq x\n for all \nx \\geq 2\n.", "id": "1658A", "url": "https://codeforces.com/contest/1658/problem/A"}
{"plan": "Let's notice that the optimal path looks like the following: \n(1, 1) \\rightarrow (1, 2) \\rightarrow \\ldots \\rightarrow (1, m) \\rightarrow (2, m) \\rightarrow \\ldots \\rightarrow (n, m)\n. The proof is relatively easy — all paths from \n(1, 1)\n to \n(n, m)\n consist of \nn + m - 1\n cells and in the optimal path we have minimized all numbers in the path. The cost of such path is equal to \n1 + 2 + \\ldots + m + 2 \\cdot m + \\ldots + n \\cdot m = \\sum\\limits_{i=1}^{m - 1} i + m \\cdot \\sum\\limits_{i=1}^n i\n. This sum can be found in \nO(n + m)\n by just summarizing all numbers, or it can be found in \nO(1)\n if you remember that \n\\sum\\limits_{i=1}^n = \\frac{n \\cdot (n + 1)}{2}\n.", "id": "1700A", "url": "https://codeforces.com/contest/1700/problem/A"}
{"plan": "Let's say we've chosen index \ni\n. What will happen? \n \n If the values of \na_i\n and \na_{i+1}\n have opposite signs, flipping them won't change the initial \nsum\n. \n if \na_i\n = \na_{i+1}\n = \n1\n, flipping them will reduce the \nsum\n by \n4\n. \n if \na_i\n = \na_{i+1}\n = \n-1\n, flipping them will increase the \nsum\n by \n4\n. \nSo, for each \ni < n\n, we can check the values of \na_i\n and \na_{i+1}\n, and we can measure the effects on the \nsum\n based on the three cases stated above. Among the effects, take the one that maximizes the \nsum\n.\nTime complexity: In each test case, \n\\mathcal{O}(n)", "id": "1778A", "url": "https://codeforces.com/contest/1778/problem/A"}
{"plan": "Considering that if we want to find the max value of \nx \\cdot y\n, then the whole string is the best to calculate, for it \n0\n s and \n1\n s are the max.\nThen considering \nx \\cdot x\n and \ny \\cdot y\n : what we need to do is to calculate the max continuous number of \n0\n or \n1\n, compare its square to the first condition, then take the bigger one as the answer. ", "id": "1750B", "url": "https://codeforces.com/contest/1750/problem/B"}
{"plan": "Let's look at a group of \nE\n: it's easy to see that each such a group is equal to the same number. Now, let's look at how these groups are distributed on the circle:\n \n If there are no \nN\n then all \na_i\n are just equal to each other. It's okay. \n If there is exactly one \nN\n then from one side, all of them are still in one group, so they should be equal, but from the other side, one pair should have different values. It's contradiction. \n If there are more than one \nN\n then all numbers are divided in several groups with different values. It's okay. \nAs a result, array \na\n exists as long as the number of \nN\n isn't \n1\n.", "id": "1620A", "url": "https://codeforces.com/contest/1620/problem/A"}
{"plan": "If \ns\n is palindromic initially, we can operate on the interval \n[1,n]\n, the answer is \nYes\n.\nLet's consider the other case. In a palindrome \ns\n, for each \ni\n in \n[1,\\lfloor n/2\\rfloor]\n, \ns_{i}=s_{n-i+1}\n must hold. For those \ni\n, we may check whether \ns_{i}=s_{n-i+1}\n is true in the initial string. For all the illegal positions \ni\n, the operation must contain either \ni\n or \nn+1-i\n, but not both. For the legal positions, the operation must contain neither of \ni\n nor \nn+1-i\n, or both of them.\nIf the illegal positions is continuous (which means that they are \nl,l+1,\\dots,r-1,r\n for some \nl\n and \nr\n), we may operate on the interval \n[l,r]\n (or \n[n+1-r,n+1-l]\n), making the string palindromic. The answer is \nYes\n.\nOtherwise, there must be some legal positions that lie between the illegal ones. Suppose the illegal positions range between \n[l,r]\n (but not continuous), and the operation is \n[o_{1},o_{2}]\n. Without loss of generality, let the operation lies in the left part of the string. Then \no_{1}\\le l,r\\le o_{2}<n+1-r\n must hold to correct all the illegal positions. This interval covers all the legal positions that lie between the illegal ones but does not cover their symmetrical positions. Thus, such kind of operation will produce new illegal positions. In other words, there are no valid operations in this situation. The answer is \nNo\n.\nTime complexity: \nO(n)\n.", "id": "1789B", "url": "https://codeforces.com/contest/1789/problem/B"}
{"plan": "Note that the game will end only when the chip is in the upper right corner (otherwise you can move it \n1\n square to the right or up). For all moves, the chip will move \nn - 1\n to the right and \nm - 1\n up, which means that the total length of all moves is \nn + m - 2\n (the length of the move is how much the chip moved per turn). Since the length of any move is odd, then after any move of Burenka, the sum of the lengths will be odd, and after any move of Tonya is even. So we can find out who made the last move in the game by looking at \n(n + m - 2) \\operatorname{mod} 2 = (n + m) \\operatorname{mod} 2\n. With \n(n + m) \\operatorname{mod} 2 = 0\n, Tonya wins, otherwise Burenka.\nThe complexity of the solution is \nO(1)\n.", "id": "1719A", "url": "https://codeforces.com/contest/1719/problem/A"}
{"plan": "A greedy strategy always works: take \nk + 1\n largest barrels, choose one barrel among them and pour all water from those barrels to the chosen barrel. That way, we make the minimum amount equal to \n0\n (it's quite obvious that we can't do anything better here), and the maximum amount as large as possible, so the difference between them will be as large as possible.", "id": "1430B", "url": "https://codeforces.com/contest/1430/problem/B"}
{"plan": "If \na_i \\gt i\n for some position \ni\n, then we need to insert at least \na_i - i\n new small elements before this position. Let \nm = max(0, \\max\\limits_{i = 1}^{n}{(a_i - i)})\n. So we need at least \nm\n operations. But its not hard to see that \nm\n operations are enough. For example, you can insert \nm\n \n1\ns at the beginning of the sequence. This way, all elements will be shifted by \nm\n positions, and consequently, will satisfy that \na_i \\le i\n for each valid \ni\n.", "id": "1604A", "url": "https://codeforces.com/contest/1604/problem/A"}
{"plan": "If necessary, change the values of \na\n and \nb\n so that \na \\le b\n is always true. Consider two cases.\n1. Let \na \\le \\frac{a + b}{4}\n. Then:\n4a \\le a + b\n, \n3a \\le b\n.\nThis means that the set \nb\n is at least \n3\n times larger than \na\n, and we can form \na\n teams of the form \n(1, 3)\n, where one participant will be a programmer and three will be mathematicians.\n2. Let \n\\frac{a + b}{4} \\le a\n. Then assume that \nb = a + d\n. Let's substitute this value into the inequality:\n\\frac{2a + d}{4} \\le a \n, \n 2a + d \\le 4a \n d \\le 2a \n, \n \\frac{d}{2} \\le a\nThen we compose \n\\frac{d}{2}\n commands of the form \n(1, 3)\n. Since making such a command decreases the value of \nd\n by 2. The new value \na' = a - \\frac{d}{2}\n, \nb' = a' + d - 2 * (\\frac{d}{2})\n. The condition \na' \\le b'\n still holds. Then make \n\\frac{a'}{2}\n commands of the form \n(2, 2)\n.\nThe total number of commands is \n\\frac{a'}{2} + \\frac{d}{2} = \\frac{2*a' + 2*d}{4} = \\frac{2*a - d + 2*d}{4} = \\frac{a + (a+d)}{4} = \\frac{a+b}{4}\n. That's what we wanted to get. ", "id": "1611B", "url": "https://codeforces.com/contest/1611/problem/B"}
{"plan": "Let \na\n be the initial string. For a string \nz\n, let's define \nz(l, r) = z_lz_{l+1} \\dots z_r\n, i.e., the substring of \nz\n from \nl\n to \nr\n. The final string is \na(k, n)\n for some \nk\n.\nIn the final string, \nx = 0\n, so the first character doesn't appear anywhere else in \ns\n. This means that \na_k\\not=a_{k+1}, a_{k+2}, \\dots, a_n\n. In other words, \na_k\n is the rightmost occurrence of a letter in \ns\n.\nCan you ever remove \na_i\n, if \na_i\\not=a_{i+1}, a_{i+2}, \\dots, a_n\n? Notice that you would need to remove \na(l, r)\n (\nl \\leq i \\leq r\n): this means that there must exist \na(l', r') = a(l, r)\n for some \nl' > l\n. So, \na_{i+l'-l} = a_i\n, and this is a contradiction.\nTherefore, \nk\n is the smallest index such that \na_k\\not=a_{k+1}, a_{k+2}, \\dots, a_n\n.\nYou can find \nk\n by iterating over the string from right to left and updating the frequency of each letter. Indeed \na_i\\not=a_{i+1}, a_{i+2}, \\dots, a_n\n if and only if the frequency of the letter \na_i\n is \n0\n up to now (in the iteration from right to left we are performing). The value of \nk\n is the minimum such index \ni\n.\nComplexity: \nO(n)", "id": "1654B", "url": "https://codeforces.com/contest/1654/problem/B"}
{"plan": "Let the maximum card among all \nn + m\n cards be \nx\n.\nIf only one player has a card of value of \nx\n, then he/she can win by playing it on the first turn or on the second turn; the opponent won't be able to respond with any of their cards.\nOtherwise (if both players have a card with value \nx\n), the player who plays this card earlier wins the game. So, in this case, the winner is the player who makes the first turn.", "id": "1681A", "url": "https://codeforces.com/contest/1681/problem/A"}
{"plan": "Accordingly, as it was said in the task, we put all tasks into the queue in the order of their arrival, then we fix the time at the beginning as \ncur\\_time = 0\n. So, while there is a task in the queue, we proceed as follows: \n \n Take the task from the queue. \n Take as time the maximum from the current and from the arrival time of the task (\ncur\\_time = max(cur\\_time, s)\n). \n We subtract the current time from the time when the task was done (\nf = d - cur\\_time\n). \n Replace the current time with the time the task was done (\ncur\\_time = d\n) \n If there is a task in the queue, go to item \n1\n. ", "id": "1690C", "url": "https://codeforces.com/contest/1690/problem/C"}
{"plan": "If \na+b+2\\leq n\n, we can always find such pair, here is a possible construction: \nThe red part is their longest common prefix, and the blue part is their longest common suffix.\nOtherwise, the two permutations must be equal, so such pair exists iff \na=b=n\n.", "id": "1761A", "url": "https://codeforces.com/contest/1761/problem/A"}
{"plan": "Let \nS\n be the sum of durations of all songs, that is \nS = a + 2 \\cdot b + 3 \\cdot c\n.\nLet's notice that since \na, b, c \\ge 1\n, it is possible to make a concert of any duration from \n0\n to \nS\n (indeed, if we just execute a greedy algorithm and take three-minute songs while possible, then take two-minute songs, and then one-minute ones, we can get any duration we need). \nNow, the answer is the remainder of \nS\n modulo \n2\n, because if \nS\n is even, then it's possible to from the first concert with duration \n\\frac{S}{2}\n, and the second one will be left with duration \nS-\\frac{S}{2}=\\frac{S}{2}\n, and the difference between the durations will be \n0\n. If \nS\n is odd, then the smallest possible difference is equal to \n1\n, let's form the first concert with duration \n\\left \\lfloor{\\frac{S}{2}}\\right \\rfloor\n, and the second one is left with duration \n\\left \\lceil{\\frac{S}{2}}\\right \\rceil", "id": "1582A", "url": "https://codeforces.com/contest/1582/problem/A"}
{"plan": "There are many ways to solve the problem. One way is to look for the following pattern: \n There can only be one such pattern if there is one bishop and it's not on the edge of the board. We can iterate through all cells and see if we can match this pattern, and if we can we output the centre cell.\nYou can also look at the positions of the two diagonals and intersect them, but it requires more implementation.\nTime complexity: \n\\mathcal{O}(1)\n per testcase.", "id": "1692C", "url": "https://codeforces.com/contest/1692/problem/C"}
{"plan": "The answer is 'yes' if and only if there are exactly \nn\n odd numbers.", "id": "1542A", "url": "https://codeforces.com/contest/1542/problem/A"}
{"plan": "Firstly, given any pair of strings of length \nm\n, we should be able to tell the difference between them. It's enough to find the sum of absolute differences between each character from the same position. Now, we should go through all possible pairs and pick the minimum value over all of them using the function we use to calculate the difference.", "id": "1676C", "url": "https://codeforces.com/contest/1676/problem/C"}
{"plan": "First, the condition about being able to construct a rectangle is the same as having two pairs of sticks of equal length.\nLet's fix the stick that we are going to break into two parts. Now there are two cases.\nThe remaining two sticks can be the same. In that case, you can break the chosen stick into equal parts to make the second equal pair of sticks. Note, however, that the stick should have an even length, because otherwise the length of the resulting parts won't be integer.\nThe remaining two sticks can be different. In that case, the chosen stick should have the length equal to their total length, because the only way to make two pairs of equal sticks is to produce the same two sticks as the remaining ones.\nOverall complexity: \nO(1)\n per testcase.", "id": "1622A", "url": "https://codeforces.com/contest/1622/problem/A"}
{"plan": "Editorial\nLet's consider the array of \nn\n elements in non-decreasing order. We can make numbers before the median equal to zero, after that we have \nm = \\lfloor {\\frac{n}{2}} \\rfloor + 1\n numbers, which sum should be \nn\n and the minimal of them (i.e. median value) should be maximized.\nTo do so, it is enough to make all these numbers equal \n\\lfloor {\\frac{s}{m}} \\rfloor\n, and then add what's left to the last number (\ns \\bmod m\n). It's easy to see that such array matches all the conditions and it is impossible to make median greater.", "id": "1566A", "url": "https://codeforces.com/contest/1566/problem/A"}
{"plan": "Notice that evolution will go on for no more than \nn\n iterations, since on each iteration at least one new living cell will appear, and if it doesn't this would mean that we remain in the same state as on the previous step and the simulation is over. Knowing this we can write a simple simulation of the process described in the problem statement, which would process each iteration in \nO(n)\n.\nFinal complexity: \nO(n^2)\n.", "id": "1523A", "url": "https://codeforces.com/contest/1523/problem/A"}
{"plan": "Claim: The string is obtainable if it ends in \n\\texttt{B}\n and every prefix of the string has at least as many \n\\texttt{A}\n as \n\\texttt{B}\n.\nAn alternative way to think about the second condition is to assign \n\\texttt{A}\n to have a value of \n1\n and \n\\texttt{B}\n to have a value of \n-1\n. Then, we are just saying that each prefix must have a non-negative sum. This is pretty similar to bracket sequences.\nNow, both conditions are clearly necessary, let us show that they are sufficient too.\nWe will explicitly construct the string (in the reverse direction). While there are more than \n1\n occurrences of \n\\texttt{B}\n in the string, remove the first occurrence of \n\\texttt{AB}\n. After doing this process, you will eventually end up with the string \n\\texttt{AAA...AAB}\n.", "id": "1672B", "url": "https://codeforces.com/contest/1672/problem/B"}
{"plan": "Note that the number \nm\n and the nearest round number not exceeding \nm\n have the same size (consist of the same number of digits in the record). Denote the size of \nm\n by \nlen\n. Then we can construct the nearest round number. It will consist of one and \nlen - 1\n zeros. ", "id": "1702A", "url": "https://codeforces.com/contest/1702/problem/A"}
{"plan": "Let \nS\n denotes sum of element of array \na\n. \nClaim\n: Answer is \n|S|\n.\nProof\n: Let sum of all positive elements is \nS_{pos}\n and sum of all negative elements \nS_{neg}\n. Put all positive numbers in first group and negative numbers in second group. We get \n||S_{pos}| - |S_{neg}|| = |S|\n.\nLet's prove that we can not do better than that. Let \nS_1\n denotes sum of elements of first group and \nS_2\n denotes sum of elements of second group. We have \n|S_1| - |S_2| \\leq |S_1 + S_2| = |S|\n. Hence \n|S|\n is the upperbound for the answer.", "id": "1747A", "url": "https://codeforces.com/contest/1747/problem/A"}
{"plan": "It's not hard to see that if \nl \\le \\lfloor \\frac{r}{2} \\rfloor + 1\n, then \nr \\bmod (\\lfloor \\frac{r}{2} \\rfloor + 1) = \\lfloor \\frac{r-1}{2} \\rfloor\n. It can be shown that the maximal possible answer.\nAt the same time, let the segment not contain number \n\\lfloor \\frac{r}{2} \\rfloor + 1\n, that is, \nl > \\lfloor \\frac{r}{2} \\rfloor + 1\n. Then we can show that the maximal answer is \nr \\bmod l = r-l\n.\nAsymptotics: \nO(1)\n per test case.", "id": "1562A", "url": "https://codeforces.com/contest/1562/problem/A"}
{"plan": "Let \nT = \n \nn\n & (\nn-1\n) & (\nn-2\n) & (\nn-3\n) & ... (\nk\n)\nIf there is at least one integer from \nK\n to \nN\n whose bit at the \ni_{th}\n index is \n0\n, then the value of the \ni_{th}\n bit in \nT\n will also be \n0\n. We can easily observe that the \nmsb\n (Highest set bit in \nn\n) in \nN\n will become \n0\n for the first time when \nK = 2^{msb}- 1\n. All the other bits will become zero when \nK = 2^{msb}\n. \nThus the answer is, \nK = 2^{msb} - 1\n.", "id": "1527A", "url": "https://codeforces.com/contest/1527/problem/A"}
{"plan": "Let's iterate through the elements of \na\n. For convenience, we'll make \na_i = \\min(a_i, m + 1 - a_i)\n. If the \na_i\n-th character of \ns\n is not currently \nA\n, then we should replace it. Otherwise, we replace the \n(m+1-a_i)\n-th character. This is because if we have the choice between replacing two characters, replacing the one with the smaller index will result in a lexicographically smaller string.\nAlternatively, we can keep track of how many times either \nx\n or \nm + 1 - x\n appears in \na\n for each \n1 \\le x \\le \\lceil \\frac{m}{2} \\rceil\n. \n \n If they appear \n0\n times, neither of these indices in \ns\n can become \nA\n. \n If they appear \n1\n time, it is optimal to set the \nx\n-th character to \nA\n, since this will produce a lexicographically smaller string. \n Otherwise, they appear at least \n2\n times, and it is possible to set both the \nx\n-th and \n(m + 1 - x)\n-th character to \nA\n. ", "id": "1706A", "url": "https://codeforces.com/contest/1706/problem/A"}
{"plan": "There are two possible solutions for the problem.\nThe first solution is basically brute force. Each password can be obtained from an integer from \n0\n to \n9999\n. If the number is from \n1000\n to \n9999\n, then it's already a password of length \n4\n. Otherwise, you have to prepend it with enough zeros so that it becomes length \n4\n.\nThen you have to check if the password is valid. First, check if it consists of exactly two different digits: make a set of all its characters (set<char> in case of C++, for example) and check its size. Then check if the first digit of the password appears exactly twice. It would mean that the other digits appears exactly twice as well. Finally, check if neither of the found digits are forbidden.\nThe second solution is based on combinatorics. First, choose the two digits that will appear in the password: \nC(10 - n, 2)\n. Since \nn\n digits are prohibited, the remaining \n10 - n\n are allowed. Second, choose the positions that will be taken by the first one: \nC(4, 2)\n. The answer is the product of these two values.", "id": "1743A", "url": "https://codeforces.com/contest/1743/problem/A"}
{"plan": "Let's try to estimate the maximum possible answer. Best case, you will be able to remove either all zeros or all ones from the entire string. Whichever has the least occurrences, can be the answer.\nIf the amounts of zeros and ones in the string are different, this bound is actually easy to reach: just choose the substring that is the entire string.\nIf the amounts are the same, the bound is impossible to reach. Choosing the entire string will do nothing, and asking a smaller substring will decrease the answer.\nThe smallest we can decrease the answer by is \n1\n. If you choose the substring that is the string without the last character, you will decrease one of the amounts by one. That will make the amounts different, and the bound will be reached.\nOverall complexity: \nO(|s|)\n per testcase.", "id": "1633B", "url": "https://codeforces.com/contest/1633/problem/B"}
{"plan": "Because we can only eat candies from boxes. The only way to make all boxes have the same quantity of candies in them would be to make all candies contain a number of candies equal to the minimum quantity of candies a box initially has. So, we should find this minimum number, let's denote it as \nm\n, and then for each box, there should be eaten \na_i - m\n candies. So the answer would be the sum of \na_i - m\n over all \ni\n-s (\n1 \\leq i \\leq n\n).", "id": "1676B", "url": "https://codeforces.com/contest/1676/problem/B"}
{"plan": "Check if the string has length 5 and if it has the characters \n\\texttt{T}, \\texttt{i}, \\texttt{m}, \\texttt{u}, \\texttt{r}\n. The complexity is \n\\mathcal{O}(n)\n. \nYou can also sort the string, and check if it is \n\\texttt{Timur}\n when sorted (which is \n\\texttt{Timru}\n).", "id": "1722A", "url": "https://codeforces.com/contest/1722/problem/A"}
{"plan": "The line we draw must go through a triangle's vertex; otherwise, two sides of the triangle are split, and one of the resulting parts becomes a quadrilateral.\nSo we need to check if it is possible to make a horizontal or vertical cut through a vertex. A horizontal cut is possible if all \ny\n-coordinates are different (we can draw it through a vertex with the median \ny\n-coordinate); a vertical cut is possible if all \nx\n-coordinates are different (we can draw it through a vertex with the median \nx\n-coordinate).\nSo, all we need to check is the following pair of conditions:\n \n all \nx_i\n are different; \n all \ny_i\n are different. ", "id": "1767A", "url": "https://codeforces.com/contest/1767/problem/A"}
{"plan": "The solution is to iterate over all possible triangles, find their areas, and compute how many of these areas are distinct. So the problem is to calculate the area of a given triangle efficiently. There are many possible ways to do it; I will describe the most straightforward method.\nRecall the formula for the triangle's area: \nAs we want to count distinct areas we can forget about dividing by \n2\n and focus on calculating \nbase \\cdot height\n. Note that all triangles are of form \n(x_1, 0)\n, \n(x_2, 0)\n and \n(0, 1)\n. Thanks to this, if we pick a side \n(x_1, 0)\n, \n(x_2, 0)\n as a base, then the height is equal to \n1\n! As a result, \nbase \\cdot height = |x_1 - x_2|\n. Final complexity is \n\\mathcal{O}(n^2)\n per test case.", "id": "1466A", "url": "https://codeforces.com/contest/1466/problem/A"}
{"plan": "Since we want to maximize the number we need, we will first find the longest suitable number. Obviously, it is better to use only the numbers \n1\n and \n2\n for this. Therefore, the answer always looks like \n2121\\ldots\n or \n1212\\ldots\n. The first option is optimal when \nn\n has a remainder of \n2\n or \n0\n modulo \n3\n, otherwise the second option is optimal.\nBelow is an example of a neat implementation.", "id": "1647A", "url": "https://codeforces.com/contest/1647/problem/A"}
{"plan": "Note that the size of the array doesn't change parity, since it always decreases by \n2\n. Let's count the number of distinct elements, call it \nx\n. \nIf \nx\n is the same parity as \nn\n (the length of the array), then we can make sure all of these \nx\n distinct elements stay in the array by removing two elements at a time. \nOtherwise, \nx\n isn't the same parity as \nn\n. Then \nx-1\n is the same parity as \nn\n, and we can make sure \nx-1\n distinct elements stay in the array by removing two elements at a time. So the answer is \nx\n if \nx\n and \nn\n have the same parity, and \nx-1\n otherwise.\nFor example: \n[15,16,16,15]\n has \nx=4\n, \nn=2\n. So \nx\n and \nn\n have the same parity, and we can get all distinct numbers \n[15,16]\n by removing \ni=3\n, \nj=4\n.\nTime complexity: \n\\mathcal{O}(n \\log n)\n or \n\\mathcal{O}(n)\n, depending on the implementation.", "id": "1692B", "url": "https://codeforces.com/contest/1692/problem/B"}
{"plan": "Sure, you can just implement the rotation operation and check all \n4\n possible ways to rotate the matrix, but it's kinda boring. The model solution does the different thing.\nIf a matrix is beautiful, then its minimum is in the upper left corner, and its maximum is in the lower right corner (and vice versa). If you rotate it, the element from the upper left corner goes to the upper right corner, and the element from the lower right corner goes to the lower left corner — so these elements are still in the opposite corners. No matter how many times we rotate a beautiful matrix, its minimum and maximum elements will be in the opposite corners — and the opposite is true as well; if you have a \n2 \\times 2\n matrix with minimum and maximum elements in opposite corners, it can be rotated in such a way that it becomes beautiful.\nSo, all we need to check is that the minimum and the maximum elements are in the opposite corners. There are many ways to do it; in my opinion, the most elegant one is to read all four elements in an array of size \n4\n; then the opposite corners of the matrix correspond either to positions \n0\n and \n3\n, or to positions \n1\n and \n2\n in this array. So, we check that the sum of positions of minimum and maximum is exactly \n3\n.", "id": "1772B", "url": "https://codeforces.com/contest/1772/problem/B"}
{"plan": "The solution of this task is to basically implement what was written in the statement.\nLet \ndep_i\n be the moment of train departure from the station \ni\n (\ndep_0 = 0\n initially). Then train arrives at the current station \ni\n at moment \nar_i = dep_{i - 1} + (a_i - b_{i - 1}) + tm_i\n and departure at moment \ndep_i = \\max(b_i, ar_i + \\frac{b_i - a_i + 1}{2})\n.\nThe answer is \nar_n\n.", "id": "1501A", "url": "https://codeforces.com/contest/1501/problem/A"}
{"plan": "For all elements of the arrays to become equal after subtraction of units, \na_i>=b_i\n for \n1 \\le i \\le n\n must be satisfied. In addition, if there exists \nb_i > 0\n, then the equality \na_i = b_i\n can be obtained only by subtracting exactly \na_i - b_i\n units from \na_i\n. Since the equality \na_i = b_i\n must be satisfied for all \ni\n, the problem is reduced to checking that for \nb_i > 0\n all differences \na_i - b_i=dif\n are equal and for \nb_i = 0\n the difference does not exceed \ndif\n.", "id": "1690B", "url": "https://codeforces.com/contest/1690/problem/B"}
{"plan": "First we can observe that if a card has \nr_i = b_i\n, then if doesn't affect the comparison between \nR\n and \nB\n regardless of its position. We can forget about all such cards. Formally, if we erase all such cards after the permutation, then \nR\n and \nB\n are still compared in the same way, and further all the remaining cards are still permuted equiprobably.\nNow we only have cards with \nr_i > b_i\n (let's call them Red-favourable) and \nr_i < b_i\n (call them Blue-favourable). But then, the comparison between \nR\n and \nB\n will only be decided by whether the first card is Red- or Blue-favourable. Naturally, if, say, there are more Red-favourable cards than Blue-favourable cards, then Red is more likely to win. If there is an equal number of Red- and Blue-favourable cards, then the chances are equal.\nThus, for the solution purposes we only need to count indices \ni\n with \nr_i > b_i\n and those with \nr_i < b_i\n, and compare these two numbers.", "id": "1459A", "url": "https://codeforces.com/contest/1459/problem/A"}
{"plan": "Noticing the hint above we now deduce \nx\n = \na\n & \nb\n where & is bitwise \nAND\n. So just printing (\na\n \n\\oplus\n (\na\n & \nb\n)) + (\nb\n \n\\oplus\n (\na\n & \nb\n)) works, but there's an even nicer formula. We'll leave it up to you to prove that (\na\n \n\\oplus\n (\na\n & \nb\n)) + (\nb\n \n\\oplus\n (\na\n & \nb\n)) = \na\n \n\\oplus\n \nb\n, where \n\\oplus\n is the bitwise \nXOR\n :)", "id": "1421A", "url": "https://codeforces.com/contest/1421/problem/A"}
{"plan": "The first solution: Fix the position of the numbers \na_n, b_n\n. And for each other index \ni\n, let's check whether the conditions \na_i \\leq a_n\n and \nb_i \\leq b_n\n are met. If not, swap \na_i\n and \nb_i\n and check again. If the conditions are not met for some index in both variants — the answer is \n\"No\"\n, otherwise \n\"Yes\"\n.\nThe second solution: Let \nM\n be the maximum of all the numbers \na_1, a_2, \\ldots, a_n, b_1, b_2, \\ldots, b_n\n. Then if \na_n < M\n and \nb_n < M\n the answer is — \n\"No\"\n, since in the one of the arrays where the number \nM\n appears after the operations, the maximum will be \nM\n, which is greater than \na_n\n and \nb_n\n. Otherwise, either \na_n = M\n or \nb_n = M\n. If \na_n = M\n, then swap \na_n\n and \nb_n\n, now \nb_n = M\n. So the condition \nb_n = \\max(b_1, b_2, \\ldots, b_n)\n will always be met, regardless of the numbers \nb_1, b_2, \\ldots, b_{n-1}\n. Therefore, it would be best to put in \nb_i\n the maximum of the numbers \na_i, b_i\n for each \ni\n. After that, it remains to check the condition for the array \na_1, a_2, \\ldots, a_n\n, and if it is met, the answer is —\n\"Yes\"\n, otherwise —\n\"No\"", "id": "1798A", "url": "https://codeforces.com/contest/1798/problem/A"}
{"plan": "Note is that after doing two operations of the same type, they are \"cancelled out\" in terms of parity, since we would change the parity of all elements once, then change it back again. \nSo, we know that we will do each operation exactly \n0\n or \n1\n time. It is possible to check all possible cases just by simulating, or we can notice that all elements on all indices of the same parity \nmust\n have the same parity and if they do we can always find an answer, by doing just a single type of operation a single time (in case the array doesn't already contain all elements of the same parity).\nThe time complexity is \n\\mathcal{O}(n)\n.", "id": "1669C", "url": "https://codeforces.com/contest/1669/problem/C"}
{"plan": "We can prove that if we have \nk_1 + k_2\n white cells on the board then we can place any \nw\n white dominoes as long as \n2w \\le k_1 + k_2\n.\nThe proof is the following: if \nk_1 \\ge k_2\n let's place one domino at position \n((1, k_1 - 1), (1, k_1))\n, otherwise let's place domino at position \n((2, k_2 - 1), (2, k_2))\n. Then we can solve the placement of \nw - 1\n dominoes in \nk_1 - 2\n cells in the first row and \nk_2\n cells of the second row recursively (or, analogically, \nk_1\n and \nk_2 - 2\n).\nAt the end, either all dominoes are placed or \nk_1 < 2\n and \nk_2 < 2\n. If \nk_1 = 0\n or \nk_2 = 0\n then, since \n2w \\le k_1 + k_2\n, then \nw = 0\n or we successfully placed all dominoes. If \nk_1 = 1\n and \nk_2 = 1\n then we, possibly, need to place one domino more — and we can place it vertically.\nWe can prove that we can place any \nb\n dominoes as long as \n2b \\le (n - k_1) + (n - k_2)\n in the same manner.\nAs a result, all we need to check is that \n2w \\le k_1 + k_2\n and \n2b \\le (n - k_1) + (n - k_2)\n.", "id": "1499A", "url": "https://codeforces.com/contest/1499/problem/A"}
{"plan": "We observe that when there is \n0\n in the sequence, it is optimal to choose \n0\n and any number other than \n0\n for each operation.\nTherefore, when there is \n0\n in the sequence, let \ncnt\n be the number of \n0\ns, the answer is \nn - cnt\n.\nOtherwise, when \n0\n does not exist in the sequence, there are two situations:\n \n \nWhen there exist two equal numbers in the sequence, we can perform the operation \n1\n time to convert it into the situation of having \n0\n in the sequence. So the answer must be \nn\n.\n \nWhen all numbers in the sequence are distinct, we can perform the operation \n2\n times to convert it into the situation of having \n0\n in the sequence. So the answer must be \nn + 1\n.\n ", "id": "1678A", "url": "https://codeforces.com/contest/1678/problem/A"}
{"plan": "Note that no matter which action is chosen, after this action is performed \n \n \nexactly\n one letter '\nB\n' is erased from the string \n \nexactly\n two letters in total are erased from the string \nLet's denote the length of the string \ns\n by \nn\n. If \nn\n is odd, then described turns can not erase all the characters from the strings, because if he is deleting two letters on each turn, the length will always remain odd. For example, if the original length of the string is \n5\n, then after one turn it will be equal to \n3\n, and after two moves it will be equal to \n1\n in which case the next turn is impossible. Thus, if the length of the row is odd, the answer is \nNO\n.\nIf \nn\n is even, it will take exactly \n\\frac{n}{2}\n steps to erase all characters from the string. Since each action removes exactly one letter '\nB\n' from the string, the string can become empty only if there are exactly \n\\frac{n}{2}\n letters '\nB\n'.\nLet us show that this condition is sufficient, that is, if a string has exactly half of the letters equal to '\nB\n', then there always exists a sequence of actions leading to an empty string. Indeed, if a string of length \nn\n has exactly \n\\frac{n}{2}\n letters '\nB\n', exactly \nx\n letters '\nA\n' and exactly \ny\n letters '\nC\n', then \nx + y = n - \\frac{n}{2} = \\frac{n}{2}\n. Then Casimir can make \nx\n moves of the first type, each time removing the first occurrence of '\nB\n' and the first occurrence of '\nA\n', and \ny\n moves of the second type, each time removing the first occurrence of '\nB\n' and the first occurrence of '\nC\n'. After \nx + y = \\frac{n}{2}\n such moves, the string will become empty.\nThus, checking that the number of letters '\nB\n' in the string is exactly half of its length was enough to solve the problem.", "id": "1579A", "url": "https://codeforces.com/contest/1579/problem/A"}
{"plan": "Considering that whichever the operation you use, the length of \na\n would decrease \n1\n.\nSo you can only modify the first \nn-m+1\n elements of \na\n, otherwise the length of \na\n can't be equal to the length of \nb\n. That means \n\\{a_{n-m+2},\\dots,a_n\\}\n must equals to \n\\{b_2,\\dots,b_m\\}\n.\nAnd about the first element of \nb\n: \n if \nb_1\n is \n0\n, you can use \nOperation 1\n to make \n0\n and remove elements. \nif \nb_1\n is \n1\n, you can use \nOperation 2\n to make \n1\n and remove elements.\nSo just check the first \nn-m+1\n elements in \na\n to find if there is anyone that equals to \nb_1\n. ", "id": "1704A", "url": "https://codeforces.com/contest/1704/problem/A"}
{"plan": "Let \nsa\n, \nsb\n are the last characters of lines \na\n and \nb\n respectively. And \n|a|, |b|\n are the sizes of these strings.\n \n \nsa \\neq sb\n: then the answer depends only on \nsa\n and \nsb\n and is uniquely defined as the inverse of \nsa\n to \nsb\n (\"\n<\n\" if \nsa > sb\n, \"\n>\n\" if \nsa < sb\n, since the characters \nS\n, \nM\n, \nL\n are in reverse order in the alphabet). \n \nsa = sb\n: \n \n \n|a| = |b|\n. Then the answer is \"\n=\n\". This also covers the case \nsa = sb = \nM\n; \n \nsa = sb =\nS\n. Then the larger the size of the string, the smaller the size of the t-shirt. That is, the answer is \"\n<\n\" if \n|a| > |b|\n and \"\n>\n\" if \n|a| < |b|\n; \n \nsa = sb =\nL\n. Then the larger the size of the string, the smaller the size of the t-shirt. That is, the answer is \"\n<\n\" if \n|a| < |b|\n and \"\n>\n\" if \n|a| > |b|\n; \n ", "id": "1741A", "url": "https://codeforces.com/contest/1741/problem/A"}
{"plan": "We will consider each character seperately. Look at the \ni\n-th character; if it is originally a \n1\n, we can either change it to a \n0\n and pay \nh + c_0\n coins for this specific character, or we can not change it and pay \nc_1\n coins for it. Since we want to pay as little as possible, we take the minimum of these two. So if the \ni\nth character is a \n1\n, we will have to pay \nmin(c_1, h + c_0)\n coins for it. A similar logic can be used for the zeroes; if the \ni\nth character is a \n0\n we will have to pay \nmin(c_0, h + c_1)\n coins. So we iterate over \ns\n, and for each character we add the required minimum to the sum, depending on whether it's a \n0\n or \n1\n.\nTime complexity: \nO(n)", "id": "1440A", "url": "https://codeforces.com/contest/1440/problem/A"}
{"plan": "There are many different ways to solve this problem:\n \n generate all Berland words with two for-loops and store them in an array, then for each test case, go through the array of words to find the exact word you need; \n generate all Berland words with two for-loops and store them in a dictionary-like data structure (\nmap\n in C++, \ndict\n in Python, etc), using words as keys and their numbers as values. This allows to search for the index of the given word quickly; \n for each test case, run two for-loops to iterate over the words, count the number of words we skipped, and stop at the word from the test case; \n try to invent some formulas that allow counting the number of words before the given one. ", "id": "1674B", "url": "https://codeforces.com/contest/1674/problem/B"}
{"plan": "If the length of the given string \ns\n is odd, then the answer is \nNO\n, since adding two strings cannot do that. Otherwise, let \nn\n be the length of the string. Let's go through the first half of the string, comparing whether its first and \n\\frac{n}{2} + 1\n characters are equal, its second and \n\\frac{n}{2} + 2\n characters are equal, and so on. If the characters in any pair are not equal, the answer is \nNO\n, otherwise — \nYES\n.", "id": "1619A", "url": "https://codeforces.com/contest/1619/problem/A"}
{"plan": "Let's look at our arrays \na\n and \nb\n. Note that for any position \np\n such that \n|a_{p-1} - a_p| + |b_{p-1} - b_p| > |a_{p-1} - b_p| + |b_{p-1} - a_p|\n we can always \"fix it\" by swapping \nall\n positions \ni\n from \np\n to \nn\n. In that case, contribution from all \ni < p\n won't change, contribution of pair \n(p - 1, p)\n will decrease and contribution from all \ni > p\n won't change again, since we swapped all of them.\nIt means that we already can use the following algorithm: while exists such \np\n that \n|a_{p-1} - a_p| + |b_{p-1} - b_p| > |a_{p-1} - b_p| + |b_{p-1} - a_p|\n just swap all \ni\n from \np\n to \nn\n. This solution works for \nO(n^2)\n per test, that should be enough.\nBut we can optimize our approach by realizing that we can (instead of searching \np\n each time) just go from \n2\n to \nn\n and fix pairs one by one: if \n|a_1 - a_2| + |b_1 - b_2| > |a_1 - b_2| + |b_1 - a_2|\n then swap \na_2\n with \nb_2\n; next, if \n|a_2 - a_3| + |b_2 - b_3| > |a_2 - b_3| + |b_2 - a_3|\n then swap \na_3\n with \nb_3\n and so on. In such way, solution works in \nO(n)\n.", "id": "1661A", "url": "https://codeforces.com/contest/1661/problem/A"}
{"plan": "Let's sort the numbers in ascending order. It becomes immediately clear that it is not profitable for us to increase the numbers that are equal to the last number (the maximum of the array). It turns out that every time you need to take such a subset of the array, in which all the numbers, except the maximums. And once for each operation, the numbers in the subset are increased by one, then how many times can the operation be performed on the array? Accordingly \nmax(a) - min(a)\n.", "id": "1624A", "url": "https://codeforces.com/contest/1624/problem/A"}
{"plan": "The solution is simple: let's create an integer variable (initially set to \n0\n) that will contain the number of considered liked integers. Let's iterate over all positive integers starting with \n1\n. Let's increase the variable only when the considered number is liked. If the variable is equal to \nk\n, let's stop the iteration and output the last considered number.\nSince the answer for \nk = 1000\n is \nx = 1666\n, the count of considered numbers is at most \n1666\n so the solution will work on the specified limitations fast enough.", "id": "1560A", "url": "https://codeforces.com/contest/1560/problem/A"}
{"plan": "Since you need \ne\n liters of essence to be exactly \nk\\ \\%\n of potion then we can write an equality: \n\\frac{e}{e + w} = \\frac{k}{100}\n or \nk = x \\cdot e\n and \n100 = x \\cdot (e + w)\n for some integer \nx\n. Since we need to minimize \ne + w\n and \nx(e + w) = 100\n, then we should maximize \nx\n, but both \nk\n and \n100\n should be divisible by \nx\n. In other words, taking \nx\n as Greatest Common Divisor of \nk\n and \n100\n is optimal.\nAs a result \ne + w = \\frac{100}{x} = \\frac{100}{\\gcd(k, 100)}\n.", "id": "1525A", "url": "https://codeforces.com/contest/1525/problem/A"}
{"plan": "Let's fix the number of people going to the cinema \nk\n and try to choose a set of this exact size. What happens to people with different \na_i\n?\n \n If \na_i < k\n, person \ni\n definitely wants to go. \n If \na_i > k\n, person \ni\n definitely does not want to go. \n If \na_i = k\n, there is actually no good outcome for person \ni\n. If person \ni\n goes to the cinema, there are only \nk - 1\n \nother\n people going, so person \ni\n will be sad (since \nk - 1 < a_i\n). If person \ni\n does not go, there are \nk\n \nother\n people going, so person \ni\n will be sad too (since \nk \\ge a_i\n). \nThus, for a set of size \nk\n to exist, there must be no people with \na_i = k\n, and the number of people with \na_i < k\n must be exactly \nk\n. We can easily check these conditions if we use an auxiliary array \ncnt\n such that \ncnt[x]\n is equal to the number of people with \na_i = x\n.\nAlternative solution\n:\nNotice that if a set of \nk\n people can go to the cinema, it must always be a set of people with the smallest \na_i\n. Thus, we can start with sorting the array \na\n in non-decreasing order.\nThen, for each length \nk\n of a prefix of this array, we can check whether the first \nk\n elements are all smaller than \nk\n, and the remaining \nn-k\n elements are all greater than \nk\n.\nHowever, since the array is sorted, it is enough to check that the \nk\n-th element is smaller than \nk\n, and the \nk+1\n-th element is greater than \nk\n.", "id": "1781A", "url": "https://codeforces.com/contest/1781/problem/A"}
