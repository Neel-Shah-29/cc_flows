{"plan": "We state that every element except for the elements with the smallest value can be deleted.Proof: denote MN as the minimum element (s) of the array a, in each operation pick MN and some other element, say X, which is bigger than MN, since AVG = \\frac{X + MN}{2} < X, then X will be deleted.Doing this for every X > MN will result in the deletion of every element except for the elements with the smallest value. So the answer to the problem is n - cntMN, where cntMN is the number of times MN appeared in a.complexity: \\mathcal{O}(n)", "id": "1529A", "url": "https://codeforces.com/contest/1529/problem/A"}
{"plan": "Let's consider that l_1, l_2, and l_3 are sorted working segments.If l_1 is not equal to 1 then we can decrease l_1 by 1 and increase l_3 by 1. So we'll increase the answer.We've got that l_1 = 1 and we have to work just with l_2 and l_3.Now, our problem can be rewritten as:l_2 + l_3 = n - 4, maximize min(l_2 - 1, l_3 - l_2).And as we know that l_3 = n - 4 - l_2, just:maximize min(l_2 - 1, n - 4 - 2 \\cdot l_2).If we increase both values under the minimum scope by one, solutions don't change:maximize min(l_2, (n - 3) - 2 \\cdot l_2).If we choose l_2 = \\left\\lfloor\\frac{n-3}{3}\\right\\rfloor, then min(l_2, (n - 3) - 2 \\cdot l_2) = \\left\\lfloor\\frac{n-3}{3}\\right\\rfloor.If the answer is greater, then l_2 > \\frac{n - 3}{3} and (n - 3) - 2 \\cdot l_2 > \\frac{n - 3}{3}, and it means that 2 \\cdot (l_2) + ((n - 3) - 2 \\cdot l_2) > n - 3 but 2 \\cdot (l_2) + ((n - 3) - 2 \\cdot l_2) = n - 3.The only thing is left to do is to calculate final answer. And it is \\left\\lfloor\\frac{n-3}{3}\\right\\rfloor - 1 or just \\left\\lfloor\\frac{n}{3}\\right\\rfloor - 2.It was a mathematician way of solving. As it's pretty obvious that l_2 is approximately \\frac{n}{3}, you could check l_2 = \\frac{n}{3} \\pm 5 and choose the best among them.", "id": "1735A", "url": "https://codeforces.com/contest/1735/problem/A"}
{"plan": "We can add or subtract 10 until the difference between a and b becomes less than 10. And if it is not 0 after all such moves, we need one additional move.Let d = |a - b| is the absolute difference between a and b. The final answer is \\left\\lfloor\\frac{d}{10}\\right\\rfloor plus one if d \\mod 10 > 0. This formula can be represented as d divided by 10 rounded up, in other words \\left\\lfloor\\frac{d+9}{10}\\right\\rfloor.", "id": "1409A", "url": "https://codeforces.com/contest/1409/problem/A"}
{"plan": "Obviously, answer does not exceed max_{1} + max_{2} - min_{1} - min_{2}, where max_{1}, max_{2} are two maximum values in the array, and min_{1}, min_{2} are two minimum values. Let's find a segment, such as this is true. For that we will look at all positions containing max_{1} or max_{2} (S_{1}) and all positions containing min_{1} or min_{2} (S_2). After that we choose a pair l \\in S_1, r \\in S_2, such as abs(r - l) is minimum possible. Complexity: O(n\\log n)", "id": "1720B", "url": "https://codeforces.com/contest/1720/problem/B"}
{"plan": "There are many ways to solve this problem. Basically, we need to check two conditions.The first one is the condition on the number of characters: n \\bmod 3 \\ne 2, since after the first key press, we get the remainder 1 modulo 3, after the second key press, we get the remainder 0 modulo 3, then 1 again, then 0 — and so on, and we cannot get the remainder 2.Then we need to check that, in each pair of characters which appeared from the same key press, these characters are the same — that is, s_2 = s_3, s_5 = s_6, s_8 = s_9, and so on.", "id": "1765B", "url": "https://codeforces.com/contest/1765/problem/B"}
{"plan": "If any element is not a perfect square, the answer is yes. Otherwise, the answer is no, because a^2*b^2*...=(a*b*...)^2.", "id": "1514A", "url": "https://codeforces.com/contest/1514/problem/A"}
{"plan": "Observe that there are exactly two strings of length n-1 (one prefix and one suffix). We will call them x and y. Then, s is a palindrome if and only if \\text{rev}(x)=y, where \\text{rev}(x) is the reversal of string x.So, to solve the problem it is enough to find the two strings of length n-1 and check if one of them is equal to the reversal of the other. This solution also works for any length greater or equal to \\lfloor \\frac{n}{2} \\rfloor.Intended complexity: \\mathcal{O}(n^2) per test case. (reading the input)", "id": "1794A", "url": "https://codeforces.com/contest/1794/problem/A"}
{"plan": "Let d be the largest decimal digit of n.Note that we need at least d binary decimals to represent n as a sum. Indeed, if we only use k < d binary decimals, no digit of the sum will ever exceed k. However, we need at least one digit equal to d.At the same time, it is easy to construct an answer with exactly d terms. Start with all terms equal to 0, and consider each digit separately. Let the i-th digit of n be a_i. Pick any a_i terms out of the d terms we have, and add 1 to their i-th digits.Therefore, the answer is d.", "id": "1530A", "url": "https://codeforces.com/contest/1530/problem/A"}
{"plan": "Let's process each character of the string from left to right and store the number of unanswered questions cnt. Initially this value equals to zero. Consider the i-th character of the string. If it equals to \"Q\", increase cnt by one. If it equals to \"A\", decrease cnt by one. If cnt has become negative, it means that some of the questions was answered several times. In this case let's assign zero to cnt.If cnt will be equal to zero after processing all string, then all questions were answered, and the answer is \"Yes\". Otherwise, the answer is \"No\".Time complexity: \\mathcal{O}(n) for each test case.", "id": "1754A", "url": "https://codeforces.com/contest/1754/problem/A"}
{"plan": "Let's analyze which values can the function g(x) have. It can be proven that the value of g(x) is equal to 10^k, where k is the number of zero-digits at the end of the number x, because f(f(x)) is the same number as x except for the fact that it doesn't have any trailing zeroes.Okay, now let's analyze when we reach the new value of g(x). 1 is the first value of x such that g(x) = 1, 10 is the first value of x such that g(x) = 10, 100 is the first value of x such that g(x) = 100, and so on. We have to calculate the maximum number that has the form 10^k and is not greater than n, and the answer is exactly k + 1.It can be done with a mathematical solution, but the most simple way to do it is read n as a string instead, and calculate its length.", "id": "1455A", "url": "https://codeforces.com/contest/1455/problem/A"}
{"plan": "The problem is equivalent to finding the farthest cell from ( x , y ). It is easy to see that, if they move optimally, ( i , j ) can reach ( x , y ) just by moving in an L shape, and this is equivalent to the Manhattan distance between the two points. The longest distance a prisoner will move on rows is max( x - 1 , n - x ), and for the columns it is ( y - 1 , m - y ). So answer is just max( x - 1 , n - x ) + max( y - 1 , m - y )", "id": "1457A", "url": "https://codeforces.com/contest/1457/problem/A"}
{"plan": "To maximize the sum of \\textbf{MEX} on prefixes we will use a greedy algorithm. Firstly we put all unique elements in increasing order to get maximal \\textbf{MEX} on each prefix. It is easy to see that replacing any two elements after that makes both \\textbf{MEX} and sum of \\textbf{MEX} less.In the end we put all elements that are not used in any order because \\textbf{MEX} will not change and will still be maximal.", "id": "1497A", "url": "https://codeforces.com/contest/1497/problem/A"}
{"plan": "It's easy to see that the FB-string repeats every 8 characters: after processing every 15 numbers, we will get the same remainders modulo 3 and 5 as 15 numbers ago, and when we process 15 consecutive numbers, we get 8 characters. So, f_{i+8} = f_i.This means that if we want to find a substring no longer than 10 characters in the FB-string, we don't need to consider more than 17 first characters of the FB-string: the substring of length 10 starting with the 8-th character ends with the 17-th character, and we don't need to consider substrings starting on positions greater than 8.So, the solution is to generate at least 17 first characters of the FB-string, and then check if the substring occurs in the generated string using a standard function like find.", "id": "1796A", "url": "https://codeforces.com/contest/1796/problem/A"}
{"plan": "Here are two solutions.Solution 1. Iterate through the string character by character. If s_i=\\texttt{R}, then t_i=\\texttt{R}; otherwise, if s_i=\\texttt{G} or \\texttt{B}, then t_i=\\texttt{G} or \\texttt{B}. If the statement is false for any i, the answer is NO. Otherwise it is YES.Solution 2. Replace all \\texttt{B} with \\texttt{G}, since they are the same anyway. Then just check if the two strings are equal.In either case the complexity is \\mathcal{O}(n) per testcase.", "id": "1722B", "url": "https://codeforces.com/contest/1722/problem/B"}
{"plan": "Notice that it never makes sense to move blocks between the towers such that neither of them is tower 1 as that can only decrease the heights. Moreover, it never makes sense to move blocks away from the tower 1. Thus, all operations will be moving blocks from some towers to tower 1.At the start, which towers can move at least one block to tower 1? Well, only such i that a_i > a_1. What happens after you move a block? Tower 1 becomes higher, some tower becomes lower. Thus, the set of towers that can share a block can't become larger.Let's order the towers by the number of blocks in them. At the start, the towers that can share a block are at the end (on some suffix) in this order. After one move is made, the towers get reordered, and the suffix can only shrink.Ok, but if that suffix shrinks, what's the first tower that will become too low? The leftmost one that was available before. So, regardless of what the move is, the first tower that might become unavailable is the leftmost available tower. Thus, let's attempt using it until it's not too late.The algorithm then is the following. Find the lowest tower that can move the block to tower 1, move a block, repeat. When there are no more towers higher than tower 1, the process stops.However, the constraints don't allow us to do exactly that. We'll have to make at most 10^9 moves per testcase.Ok, let's move the blocks in bulk every time. Since the lowest available tower will remain the lowest until you can't use it anymore, make all the moves from it at the same time. If the current number of blocks in tower 1 is x and the current number of blocks in that tower is y, \\lceil\\frac{y - x}{2}\\rceil blocks can be moved.You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height.Overall complexity: O(n \\log n) per testcase.", "id": "1767B", "url": "https://codeforces.com/contest/1767/problem/B"}
{"plan": "We describe two solutions. The first focuses on maximal contiguous intervals of values. We notice that for each such interval [l, r] it can either remain unchanged or get increased to [l, r + 1] (other possibilities won't increase the number of different elements; thus, we don't need to consider them). From this observation, we conclude that the result is the number of different elements in the input increased by the number of intervals containing at least one duplicate.The second is based on a simple, greedy approach, where we analyze the elements in nondecreasing order. While analyzing, we keep the set of elements for which we have already decided its value. When we want to add the next element, then we check if it is in the set. If it is, we increase it by 1; otherwise, we keep it as it is.", "id": "1466B", "url": "https://codeforces.com/contest/1466/problem/B"}
{"plan": "Let's think: what properties do all interesting numbers have? Well, if a number x does not end with 9, we can say for sure that f(x+1) = f(x) + 1, because the last digit will get increased. What if the number ends with 9? Then the last digit will become 0, so, no matter what happens to other digits, we can say that f(x+1) will surely be less than f(x). So the problem asks us to count all numbers 1 \\le x \\le n with the last digit equal to 9. It is not hard to see that the answer is equal to \\lfloor \\frac{n + 1}{10} \\rfloor. This concludes the solution, as we are now able to answer all testcases in O(1), resulting in total O(t) runtime.", "id": "1553A", "url": "https://codeforces.com/contest/1553/problem/A"}
{"plan": "There are multiple ways to solve this problem.Most interpreted languages have some function that takes the string, evaluates it as code, and then returns the result. One of the examples is the eval function in Python. If the language you use supports something like that, you can read the input as a string and use it as the argument of such a function.Suppose you use a language where this is impossible. There are still many approaches to this problem. The most straightforward one is to take the first and the last characters of the input string, calculate their ASCII codes, and then subtract the ASCII code of the character 0 from them to get these digits as integers, not as characters. Then you can just add them up and print the result.", "id": "1772A", "url": "https://codeforces.com/contest/1772/problem/A"}
{"plan": "Let's note that since all a_i are positive, any a_i + a_j > \\max(a_i, a_j). It means that we can't make the first and second minimums lower than they already are: suppose the first and second minimums are mn_1 and mn_2, if we choose any other element to replace, we can't make it less than mn_1 + mn_2 and if we choose to replace mn_1 or mn_2 we will only make them bigger.As a result, it means that we can choose for each element either not to change it or make it equal to mn_1 + mn_2. So, to be able to make all elements \\le d we need just check that either mn_1 + mn_2 \\le d or maximum a_i \\le d.We can do it, for example, by sorting our array a in increasing order and checking that either a_1 + a_2 \\le d or a_n \\le d.", "id": "1473A", "url": "https://codeforces.com/contest/1473/problem/A"}
{"plan": "You can notice that the  i -th number in the array will be included in the sum i times, which means that the value  \\frac {a_i} {i}  will add  a_i  to the sum. That is, the permutation of the elements does not affect the required sum, and therefore it is enough to check whether the sum of the array elements is equal to the given number.", "id": "1436A", "url": "https://codeforces.com/contest/1436/problem/A"}
{"plan": "To find a number that differs from the rest of the numbers in the array, you need to iterate through the array, maintaining two pairs of numbers (x_1, c_1) and (x_2, c_2), where x_i is a number from the array, c_i is how many times the number x_i occurs in the array.Then, to get an answer, you need to find the position of the x_i that occurs in the array exactly once (i.e. c_i = 1).", "id": "1512A", "url": "https://codeforces.com/contest/1512/problem/A"}
{"plan": "In this problem, you can implement an algorithm opposite to that given in the condition. Let's maintain two pointers to the left-most and right-most unhandled element. Then, restoring the original array, you:   put the left-most unhandled item in the first position  put the right-most unhandled item in the second position  put the left-most unhandled item in the third position  put the right-most unhandled item in the fourth position  ...  That is, in general, you put the leftmost elements on all odd positions, and the rightmost ones on all even positions. After processing each element, you either move the left pointer forward by one, or the right one backward by one.", "id": "1462B", "url": "https://codeforces.com/contest/1462/problem/B"}
{"plan": "Notice that you may assume that the judge has sent a message at minute 0 and at minute 1440 and\nthis does not change the answer (but it simplifies the reasoning and the implementation).\nLet us consider two consecutive messages sent by the judge, at times s < t.\nIf t − s < 120, then the judge cannot have walked the dog between the two messages.\nIf 120 ≤ t − s < 240, then the judge may have walked at most once between the two messages.\nIf 240 ≤ t − s, then the judge may have walked the dog two times between the two messages.\nHence, if ai+1 − ai ≥ 240 for some i, then the answer is YES. If ai+1 − ai ≥ 120 for two distinct\nvalues of i, then the answer is YES. Otherwise the answer is NO.", "id": "1776A", "url": "https://codeforces.com/contest/1776/problem/A"}
{"plan": "For each index i (k + 1 \\le i \\le n), there is exactly one element among a_1 to a_k, which can swap with a_i. If a_i is greater than that element, swap them. This process perform the operation at most n - k times. After performing operations, select a_1 to a_k. This is the maximum score we can get.", "id": "1733A", "url": "https://codeforces.com/contest/1733/problem/A"}
{"plan": "You need to implement what is written in the statement. To quickly check if a word is written by another guy, you should store some map<string, int> or Python dictionary, and increment every time you see a new string in the input. Then, you should iterate through each guy, find the number of times their word appears, and update their score. The complexity is \\mathcal{O}(n \\log n) per testcase.", "id": "1722C", "url": "https://codeforces.com/contest/1722/problem/C"}
{"plan": "Notice that only the following pairs of numbers are possible: (x, x), (x, 2 \\cdot x), and (x, 3 \\cdot x). Proof:Let d = gcd(a, b). Now notice that it's impossible that a = k \\cdot d for some k > 4, because otherwise lcm will be at least k \\cdot d > 3 \\cdot d. Therefore the only possible cases are the pairs listed above and (2 \\cdot d, 3 \\cdot d), but in the latter case we have lcm = 6 \\cdot d.The number of the pairs of the first kind is n, of the second kind is 2 \\cdot \\lfloor \\frac{n}{2} \\rfloor, and of the third kind is 2 \\cdot \\lfloor \\frac{n}{3} \\rfloor (the factor 2 in the latter two formulae arises from the fact that pairs are ordered). Therefore, the answer to the problem is n + 2 \\cdot \\left( \\lfloor \\frac{n}{2} \\rfloor + \\lfloor \\frac{n}{3} \\rfloor \\right).", "id": "1717A", "url": "https://codeforces.com/contest/1717/problem/A"}
{"plan": "Let's first determine whether it's possible for two trains that start from (i,0) and (0,j) to crash into each other. For this to happen, there must be a point where (i,T)=(T,j), which means i=T and j=T. Therefore, a train that starts from the bottom end can crash into a train that starts from the left end if and only if they have the same train number. We can cancel either one of them to prevent that crash.Since n and m are small, we can brute-force every pair of trains and count the number of pairs of trains that share the same number, and print that value as the answer. The time complexity for this solution is \\mathcal{O}(nm) for each test case.If we want an asymptotically faster solution, we can put all train numbers into a binary search tree structure (such as std::set in C++), and then find duplicate numbers from the trains of the other side by searching for those values. Another similar solution is to sort the former numbers, then perform binary search for the other values. The time complexity for these solutions is \\mathcal{O}((n+m)\\log(n)).There is another solution with \\mathcal{O}(n+m) time complexity taking advantage of the fact that the train numbers are small. Let's make an array X of length 101, and set X[i] = true if and only if there is a train starting from (i, 0). For each train starting from (0, j), we can check if X[j] is true, and count the total number of duplicates this way.", "id": "1453A", "url": "https://codeforces.com/contest/1453/problem/A"}
{"plan": "The first spell looks pretty weak compared to the second spell. Feels like you almost always replace one with another. Let's show that you can totally avoid casting the spell of the first type twice or more on one monster.Let the two first spell casts be (i, j) and (i, k) for some monsters i, j and k. You can replace them by a cast of the second spell on i and a cast of the first spell on (j, k). That would deal even more damage to i and the same amount to j and k. The number of casts doesn't change.Thus, it only makes sense to use the first spell on monsters with 1 health. Calculate the number of them, kill the full pairs of them with the first spell, and use the second spell on the remaining monsters.Overall complexity: O(n) per testcase.", "id": "1792A", "url": "https://codeforces.com/contest/1792/problem/A"}
{"plan": "Let's call a set of cells being filled from the topmost row to the leftmost column a layer. E. g. the 1-st layer consists of the single number 1, the 2-nd layer consists of the numbers 2, 3 and 4, the 3-rd layer consists of the numbers 5, 6, 7, 8 and 9, etc.The number of cells in layers forms an arithmetic progression. The first layer consists of a_1 = 1 cells, the i-th layer consists of a_i = a_{i-1} + 2 cells. The minimum number in the i-th layer x_i is equal to the sum of sizes of all layers from the 1-st to the (i - 1)-th plus 1.Suppose that k belongs to the i-th layer. Consider the value of m = k - x_i + 1. Polycarp fills exactly i cells on the i-th layer before he starts filling the cells from the right to the left (i. e. while he goes down). Therefore, if m \\le i, the number k belongs to the m-th row and the i-th column. Otherwise, the number belongs to the i-th row and the (i - (m - i))-th column.Consider a way to find the coordinates of a given number k. Let's iterate by the layer number i to which given the number belongs calculating the values of a_i and x_i (going to the next layer, let's calculate the next layer parameters as follows: x_{i + 1} := x_i + a_i; a_{i + 1} := a_i + 2). The iteration must be stopped if the layer number i is such that x_i \\le k < x_{i + 1}. Using the values of i and x_i, we can calculate the given number's coordinates in the described way in O(1). The total time of calculating the coodrinates for one given k is O(i_k) where i_k is the number of the layer to which the given k belongs.Let's represent the value of x_i as x_i = f(i): x_i = 1 + \\sum\\limits_{j = 1}^{i - 1} a_j = 1 + \\sum\\limits_{j = 1}^{i - 1} (2j - 1) = 1 + \\frac{1 + 2(i - 1) - 1}{2} \\cdot (i - 1) = 1 + (i - 1)^2. 1 + (i_k - 1)^2 = x_{i_k} \\le k < x_{i_k + 1} = 1 + i_k^2, hence i_k \\approx \\sqrt(k). Therefore, the coordinates of one number k may be calculated in O(\\sqrt{k}). At the same time, as it follows from the formulas, the layer number i_k can be calculated as follows: i_k = \\lceil \\sqrt{k} \\rceil (the square root of k rounded up). To avoid accuracy problems, you can calculate the value using a loop.", "id": "1560C", "url": "https://codeforces.com/contest/1560/problem/C"}
{"plan": "Let's define cnt to represent the number of 1s in the array.For the modifications, if a_i is already 1 now, then we let cnt \\gets cnt - 1. Otherwise, let cnt \\gets cnt + 1.For the querys, just compare cnt with k. If cnt \\ge k, the answer will be 1. Otherwise, the answer will be 0.The complexity : O(n + q).", "id": "1491A", "url": "https://codeforces.com/contest/1491/problem/A"}
{"plan": "Let's prove that the color with the maximum value of cnt is one of the possible answers. Let the color x have the maximum value of cnt; if there are several such colors, choose any of them. Let's keep taking the balls of two different colors out of the bag without touching the balls of color x for as long as possible.After such operations, two cases exist. In one case, only balls of color x are left — then everything is fine. In other case, there are balls of color x and some color y (let cnt_y be the remaining number of balls of this color). Since initially cnt_x was one of the maximums, cnt_y \\le cnt_x. However, the number of remaining balls is odd, which means cnt_y \\ne cnt_x and cnt_y < cnt_x. Therefore, we can keep taking the balls of colors y and x until only balls of color x are left.", "id": "1728A", "url": "https://codeforces.com/contest/1728/problem/A"}
{"plan": "In the problem, you had to find the largest common prefix(LCP) of the first 30 characters of the number \\pi and the string n. To do this, we will go from the beginning and compare the characters until we find a non-matching one, or until the string n ends.", "id": "1790A", "url": "https://codeforces.com/contest/1790/problem/A"}
{"plan": "Key Idea:For n > 3, the answer is 2 when n is even and 3 when n is odd. Cases when n \\leq 3 can be handled separately.Solution:Case 1: n \\leq 3For n = 1, 2, 3, it can be shown that the minimum number of operations required are 0, 1, 2 respectively.Case 2: n > 3 and n is evenIf n is even and greater than 2, then \\frac{n}{2} is a proper divisor. So we can divide n by \\frac{n}{2} to make it 2 and then subtract 1. This requires 2 operations.Case 3: n > 3 and n is oddIn this case, n can be made even by subtracting 1. From case 2, it can be seen that it will take 2 more operations. Thus a total of 3 operations are required.Time complexity: O(1) per case", "id": "1451A", "url": "https://codeforces.com/contest/1451/problem/A"}
{"plan": "We claim that we can sort the array if and only if a_1 = 1.NecessityWe can notice that index 1 cannot be affected by any swap operation.Let's see what happens to the value 1. According to the definition of the operation, it can either increase or be swapped. In order to be increased, there must exist some k such that 1 > a_k, but since 1 is the minimum possible value, it will never be true as other values in array a can only increse as well. Since index 1 can not be affected by a swap operation and a_1>1, we conclude that if a_1 \\neq 1, the answer is No.SufficiencyLet's focus on the second operation. Since we have a_1 = 1, we can always choose i=1 and the operation then turns into picking some pair 2 \\le j < k \\le n and swapping a_j with a_k. It's trivial to see we can always sort with such an operation.", "id": "1750A", "url": "https://codeforces.com/contest/1750/problem/A"}
{"plan": "For convenience let's define going upward as decreasing x coordinate, downward — increasing x, left — decreasing y, right — increasing y.One of the optimal solutions is the following:  Megan goes upward to Stanley, she spends (n - 1) units of energy for that. Then she goes right to her final destination by spending (m - 1) more units of energy. Stanley now has a choice: he obviously has to teleport from his starting position either all the way down, or right. He chooses what will save him the most energy, so he teleports along the greater wall of the shop for the 1 unit of power. Then Stanley has to finish his route: he walks along the smaller side and spends min(n, m) - 1 more energy. If at least one of the dimensions is not 1, then the answer is (n - 1) + (m - 1) + 1 + (min(n, m) - 1) = min(n, m) + n + m - 2. In case where (n, m) = (1, 1) answer is 0. Normal proof1715A - CrossmarketObviously, except for 1 case, it is always beneficial for Stanley to use teleportation. Let the first portal he visited be A, and the last is B. It is also obvious, that teleporting for more than 1 time makes no sense, so that's why we consider, that he always teleports from A to B and that's it.For the sake of convenience let's define manhattan distance between two points as dist(P_1, P_2) = |{P_1}_x - {P_2}_x| + |{P_1}_y - {P_2}_y|.Consider the next few cases for the relative position of those two portals:  A_x \\le B_x and Ay > By Megan must make at least (n-1) + (m-1) moves. The portal does not help Stanley in the y direction, so he must make at least (m-1) moves.  A_x > B_x and A_y \\le B_y Megan must make at least (n-1) + (m-1) moves. The portal does not help Stanley in the x direction, so he must make at least (n-1) moves.  A_x \\le Bx and Ay \\le By Megan must make at least dist(A,B) moves between A and B. Going between A and B either undoes Megan's progress in the x direction or y direction (depending on which is visited first), so she must make at least an additional (n-1) or (m-1) moves. Stanley must make at least (n-1) + (m-1) - dist(A,B) moves.  Ax > Bx and Ay > By Megan must make at least (n-1) + (m-1) moves. Using the portal undoes Stanley's progress in both the x and y directions, so he must make at least (n-1) + (m-1) moves.In all cases, the total number of moves is at least (n-1) + (m-1) + min(n-1, m-1). Proof, director's cut (or how you should not do)In a while, after I came up with an idea for this task, I got excited to proof it formally. I was very happy with the result — A's proof was longer than a regular editorial for Fdiv2, or even Fdiv1. A couple of days before the round Monogon told us that there is a solution much easier to understand, for which I am very grateful! But I would like to save the original version as an example, of how you should not prove the easiest task in your contest. 1715A - CrossmarketProof:To start with, Stanley and Megan can complete their steps in any order. So, again, for our convenience let's reorder their moves in such a way, that firstly Megan finishes her route and places portals, and then Stanley does what he needs to do.What is always the optimal route for Stanley? He goes to the nearest cell with the teleport and then teleports to the nearest possible cell to his finish. It is obvious, that Stanley can always complete his route without going left or up (except for the teleportations).Let's try to prove a similar statement for Megan: she can always plan her route avoiding moves left or down. These two cases are almost equivalent, so we will consider the first one.Let's assume that teleportations are free for Megan. Consider any cell, from which she made her move to the left. Then it is possible to \"shift\" a segment of the route to the right in order to decrease its length at least by one in conjunction with getting rid of at least one move to the left. More formally we need to construct a new route for her, so the following conditions are met: for each cell in the previous route either itself, or her right neighbor is included in the new route. This can be done by the following algorithm: we will consider cells from the original route A in order of installation of the portals, and build the new route B in parallel. If we cannot include the cell (x, y) from A to the route B because it does not have adjacent sides to any of the cells from B. Then we can include the cell (x, y + 1) to B (it cannot be out of bounds). Let there be a cell (x_1, y_1) in A with a portal, that was installed earlier than in our current cell, and that is adjacent to our current cell. If we could not include cell (x, y) to the route B, that it means that we also did not include the cell (x_1, y_1) there, thus cell (x_1, y_1 + 1) is in B, that also also allows us to include cell (x, y + 1).After such an operation Stanley's energy consumption could increase at most by 1. Though energy spent by Megan decreased at least by one. That means that our new route is not more energy-consuming. That way Megan will never go left or down, so she will spend at least (n - 1) + (m - 1) = n + m - 2 units of power.If, when all the operations are applied, Stanley teleports from the cell (x_1, y_1) to (x_2, y_2), then  \\left[ \\begin{array}{c} x_1 \\le x_2, y_1 \\ge y_2 \\\\ x_1 \\ge x_2, y_1 \\le y_2 \\\\ \\end{array} \\right. . In the first case he teleports along Megan's route and approaches his finish by (x_2 - x_1) - (y_1 - y2), and in the second case he teleports across Megan's route and approaches his destination by (y_2 - y_1) - (x_1 - x2). As you can easily notice, first's expression maximum is n - 1, and second's is m - 1. Hence Stanley will spend at least (n - 1) + (m - 1) - max(n - 1, m - 1) = n + m - max(n, m) - 1 units of power. After adding only teleportation we get n + m - max(n, m)We got two lower bounds, that in sum are n + m - 2 + n + m - max(n, m) = 2n + 2m - max(n, m) - 2 = n + m + min(n, m) - 2, which is not better, than our solution's answer, even though we did not consider Megan's teleportations.", "id": "1715A", "url": "https://codeforces.com/contest/1715/problem/A"}
{"plan": "The answer is the number of 1s modulo 2.We can get that by adding '-' before the \\text{2nd}, \\text{4th}, \\cdots, 2k\\text{-th} 1, and '+' before the \\text{3rd}, \\text{5th}, \\cdots, 2k+1\\text{-th} 1.", "id": "1774A", "url": "https://codeforces.com/contest/1774/problem/A"}
{"plan": "If we take two elements a_1 and a_2 and do the operation on it as a_1 \\cdot a_2 = x \\cdot y, then it is easy to observe that x + y will attain its maximum value when one of them is equal to 1. So, the solution for this is x = 1 and y = a_1 \\cdot a_2.Let n be the total number of elements and P (P = a_1 \\cdot a_2 \\cdot \\ldots \\cdot a_n) be the product of all elements.Now if we do the above step for every pair of elements, then the maximum value of the sum is achieved when a_1 = 1, a_2 = 1, \\dots, a_{n-1} = 1 and a_n = P.In the final array, assign P to a_1 and assign 1 to all the remaining elements a_2, a_3, \\dots a_n.So, our answer is simply P + n - 1 multiplied by 2022, of course.Time complexity: O(n).", "id": "1731A", "url": "https://codeforces.com/contest/1731/problem/A"}
{"plan": "Considering an array a of n (n\\geq 2) positive integers, the following inequality holds for 2\\leq i\\leq n:  \\gcd(a_1,a_2,\\cdots,a_i) \\leq \\gcd(a_1,a_2) \\leq 2 Therefore, when the prefix [a_1,a_2] of a is good, we can show that all the prefixes of a whose length is no less than 2 are good, then a is beautiful. It is obvious that [a_1, a_2] is good when a is beautiful. So we get the conclusion that a is beautiful if and only if the prefix [a_1, a_2] is good.We can check if there exist a_i, a_j (i\\neq j) such that \\gcd(a_i, a_j)\\leq 2. If so, we can move a_i,a_j to the front of a to make it beautiful, then the answer is Yes. If not, the answer is No.Time complexity: O(n^2\\log 10^6).", "id": "1789A", "url": "https://codeforces.com/contest/1789/problem/A"}
{"plan": "First, note that m is always less than or equal to n. If there were at least n+1 rooks on the board, at least two of them would share a row or a column (by pigeonhole principle).If m < n, then there is always at least one free row and at least one free column. You can move any rook into that row or column.Otherwise, all rows and columns are taken, so any move will make two rooks share a row or a column, which is prohibited.Thus, if m = n, then it's \"NO\". Otherwise, it's \"YES\".Overall complexity: O(1) per testcase.Alternatively, you could check every rook and every possible move.Overall complexity: O(m^2 \\cdot n^2) per testcase.", "id": "1749A", "url": "https://codeforces.com/contest/1749/problem/A"}
{"plan": "If there are two elements with the same value, then the answer is NO, because neither of these values is less than the other.Otherwise, the answer is YES, since we can just sort the array.The time complexity is \\mathcal{O}(n \\log n) or \\mathcal{O}(n) depending on the implementation.", "id": "1742B", "url": "https://codeforces.com/contest/1742/problem/B"}
{"plan": "It is easy to observe that the second operation needs to be performed at most once. Now, we just need to check 2 cases, one in which the re-arrangement operation is used, and one in which it is not.If the re-arrangement operation is to be used, then we just need to make the counts of 0s and 1s in a equal to that of b. Without loss of generality assume a contains x more 0s than b, then the cost in this case will just be x + 1 (extra one for re-arrangement cost).If the re-arrangement operation is not to be used, then we just need to make each element of a equal to the corresponding element of b.Finally, our answer is the smaller cost of these 2 cases.Time complexity is O(n).", "id": "1736A", "url": "https://codeforces.com/contest/1736/problem/A"}
{"plan": "Note that if \\left\\lfloor \\frac{l}{a} \\right\\rfloor < \\left\\lfloor \\frac{r}{a} \\right\\rfloor then exists such k \\cdot a that l \\le ka \\le r and, obviously, a customer, who wants to buy ka cans won't buy more than he wants.That's why \\left\\lfloor \\frac{l}{a} \\right\\rfloor = \\left\\lfloor \\frac{r}{a} \\right\\rfloor and we can rephrase our task as finding such a that \\frac{a}{2} \\le (l \\bmod a) \\le (r \\bmod a) < a. The longer the segment [\\frac{a}{2}, a) is the better and the maximum we can take is a = 2l. As a result, we need to check that r < a \\leftrightarrow r < 2l.", "id": "1437A", "url": "https://codeforces.com/contest/1437/problem/A"}
{"plan": "If we cut the sheet in width, we will reduce its width by half, without changing the height. Therefore, the width and height dimensions do not affect each other in any way.Let's calculate the maximum number of sheets that we can get by cutting. Let's say that initially this number is 1. Let's cut the sheet in width. Then the sheets number will become 2, but they will be the same. If we can cut the sheet again, it is more profitable to cut all the sheets we have, because this way we will get more new sheets and their size will still be the same.So we can maintain the current number of identical sheets and as long as either the width or height is divided by 2, divide it, and multiply the number of sheets by two.", "id": "1472A", "url": "https://codeforces.com/contest/1472/problem/A"}
{"plan": "For a start, let's find the position of the letter 'a' in string s. If this position does not exist, then the answer would be 'NO'. Suppose that this position exists and equals \\text{pos}_a. Let's create two pointers L and R. Initially L := \\text{pos}_a,~R := L. We will try to build string s using the algorithm from the statement. Suppose that we have built substring s[L..R] in i iterations. Consider the next letter of the Latin alphabet c_i. Let's look at cases:   find position pos of the letter c_i in s (if it does not exist then 'NO');  if pos = L - 1 then make an assignment L := L - 1 and process the next letter c_i;  if pos = R + 1 then make an assignment R := R + 1 and process the next letter c_i;  otherwise string s is not alphabetical and the answer is 'NO'.  So, if we have built the string in n iteration, then string s is alphabetical and the answer is 'YES'.", "id": "1547B", "url": "https://codeforces.com/contest/1547/problem/B"}
{"plan": "Let \\texttt{sort}(s) be s sorted alphabetically. The answer to the problem is the number m of mismatches between s and \\texttt{sort}(s) (i.e., the positions with different characters in the two strings).Choosing k=m characters is sufficient. Let us choose the mismatched characters between s and \\texttt{sort}(s), and permute them so that they are sorted alphabetically. It is not hard to prove that the resulting string will coincide with \\texttt{sort}(s).Choosing strictly less than m characters is not sufficient. If k < m, by the Pigeonhole Principle at least one of the mismatched characters will be left out, and thus it will prevent the final string from being ordered alphabetically.Complexity: O(n\\log n).", "id": "1552A", "url": "https://codeforces.com/contest/1552/problem/A"}
{"plan": "First, we need to check whether n is the multiple of 2050. If n is not the multiple of 2050, the answer is always -1.Then we can divide n by 2050, the problem now is how to represent n as the sum of powers of 10. So the answer is the sum of its digits in decimal representation.\n#", "id": "1517A", "url": "https://codeforces.com/contest/1517/problem/A"}
{"plan": "The maximum sum we can construct with n elements is 1 + 3 + 5 + 7 + \\dots + 2n-1 = n^2, so we need at least \\lceil\\sqrt{s}\\rceil elements to construct the sum equal to s. Let's show how to express s with exactly \\lceil\\sqrt{s}\\rceil elements.Let \\lceil\\sqrt{s}\\rceil = d. By taking 1 + 3 + 5 + 7 + \\dots + 2d-3, we achieve a sum of (d-1)^2 using d - 1 elements. s - (d-1)^2 is not less than 1 and not greater than 2d-1 (since \\sqrt{(d-1)^2} = d-1, and \\sqrt{(d-1)^2 + 2d} > d). Thus, we can just add s - (d-1)^2 to our array, and the sum becomes exactly s.So, the solution is to find the minimum n such that n^2 \\ge s.", "id": "1550A", "url": "https://codeforces.com/contest/1550/problem/A"}
{"plan": "Let us add to s the sum of the elements of the array b and try to find a suitable permutation. To do this, greedily add elements 1, 2, \\dots, cnt until their sum is less than s. And at the end we will check that the sum has matched. Also check that the maximal element from b: max(b) \\le cnt, and that the total elements in b: n \\le cnt.", "id": "1759B", "url": "https://codeforces.com/contest/1759/problem/B"}
{"plan": "We first sort the array a in non-decreasing order.\nDenote the indices of the elements that we choose from a to be x, y, and z, where 1 \\le x < y < z \\le n, and the final value (after performing the operations) of the concerned elements to be v.\nThe minimum required number of operations is then |a_x-v|+|a_y-v|+|a_z-v|. It is well-known that such expression attains its minimum value when v is the median of a_x, a_y, and a_z. Since the array a has already been sorted, it is best to assign v to be a_y.\nOur expression then becomes |a_x-a_y|+|a_y-a_y|+|a_z-a_y|=(a_y-a_x)+0+(a_z-a_y)=a_z-a_x. We would like to minimize the value of a_z, which implies z should be as small as possible since a is sorted. It is clear that taking z=y+1 would minimize the value of the expression. Similarly, we can show that we can take x=y-1 to minimize the value of the expression.\nTherefore, the only possible values of the triplets (x,y,z) are of the form (t,t+1,t+2) for positive integers 1 \\le t \\le n-2, and we can iterate through all such triplets and find the best one.\nThe time complexity is", "id": "1734A", "url": "https://codeforces.com/contest/1734/problem/A"}
{"plan": "Make a copy of the array s: call it t. Sort t in non-decreasing order, so that t_1 is the maximum strength and t_2 — the second maximum strength.Then for everyone but the best person, they should compare with the best person who has strength t_1. So for all i such that s_i \\neq t_1, we should output s_i - t_1. Otherwise, output s_i - t_2 — the second highest strength, which is the next best person.", "id": "1760C", "url": "https://codeforces.com/contest/1760/problem/C"}
{"plan": "You should count the number of parentheses at the end of the string, suppose there are x such parentheses. Then if x > \\frac{n}{2}, message is bad. Note that you should divide n by 2 without rounding. Or you can compare 2 \\cdot x and n instead. If 2 \\cdot x > n, the message is bad.", "id": "1411A", "url": "https://codeforces.com/contest/1411/problem/A"}
{"plan": "Note that whichever path you choose, the total cost will be the same. If you know that the cost is the same, then it's not hard to calculate it. It's equal to n \\cdot m - 1. So the task is to check: is k equal to n \\cdot m - 1 or not.The constant cost may be proved by induction on n + m: for n = m = 1 cost is 1 \\cdot 1 - 1 = 0. For a fixed (n, m), there are only two last steps you can make:   either from (n, m - 1) with cost n: the total cost is n \\cdot (m - 1) - 1 + n = n \\cdot m - 1  or from (n - 1, m) with cost m: the total cost is (n - 1) \\cdot m - 1 + m = n \\cdot m - 1. So, whichever path you choose, the total cost is the same.", "id": "1519B", "url": "https://codeforces.com/contest/1519/problem/B"}
{"plan": "According to the problem, the arrays a and b denote the dimensions of the rectangles. Define arrays c and d as a certain orientation configuration of the rectangles with c_i denoting the width and d_i denoting the height. Define arrays e and f as a certain permutation of the orientation configuration such that the i-th rectangle from the left has width e_i and height f_i.Consider a certain configuration of e and f. The perimeter of the connected shape will be 2(e_1+e_2+\\ldots+e_n)+f_1+|f_1-f_2|+|f_2-f_3|+\\ldots+|f_{n-1}-f_n|+f_n.Notice that if we sort the rectangles based on f_i, the perimeter would become 2(e_1+e_2+\\ldots+e_n+f_n). This is actually the minimum possible perimeter for a fixed configuration of c and d as we cannot get a smaller perimeter than this. This means, if we have a certain configuration of c and d, the optimal perimeter is 2(c_1+c_2+\\ldots+c_n+\\max(d)). Now, we just need to find a configuration of c and d from a and b that results in the minimum value of 2(c_1+c_2+\\ldots+c_n+\\max(d)).Notice that each element of a and b can only be counted either 0 or 2 times in the final answer. Consider the maximum value out of all elements of a and b. If there are multiple values that are maximum, just consider one of them. We can see that that value will always be counted 2 times no matter how we construct c and d.We need to determine whether to put that maximum value in c (width) or d (height). It is actually better to put that value in d as it will cause all other values of d to be counted 0 times in the final answer.Now, we just need to determine the orientation for each of the other rectangles. We have determined that the maximum value in a and b must be put in d, which will automatically become the value of \\max(d). Therefore, all other values in d will be counted 0 times in the final answer. This means, because we want to minimise the final answer, for each i, it is always better to put the larger value out of a_i and b_i in d as it will cause the value that is not being counted in the final answer to be larger.Using every observation above, in order to get the minimum possible perimeter, we can do the following:   Construct the arrays c and d with c_i and d_i taking their values from a_i and b_i while making c_i\\leq d_i.  The answer is 2(c_1+c_2+\\ldots+c_n+\\max(d)). Time complexity for each test case: O(n)", "id": "1740B", "url": "https://codeforces.com/contest/1740/problem/B"}
{"plan": "Note that it does not make sense to move several blocks first from the left tower to the right, and then from the right to the left, since this is similar to canceling the last actions.Using the fact described above and small restrictions on the input data, one of the possible solutions is the following: choose which tower will be the one where we take blocks from (try both options), iterate over the number of operations, and then check that both towers are beautiful after that number of operations.There is a faster solution: move all the blocks to the left tower, and then check that there is no more than one pair of adjacent blocks of the same color. If there are no such pairs, then we can divide the tower into two in an arbitrary way, and if there is exactly one pair, then we need to make a \"cut\" exactly between two blocks of the same color. Otherwise, there will always be a pair of adjacent blocks of the same color in one of the towers.", "id": "1795A", "url": "https://codeforces.com/contest/1795/problem/A"}
{"plan": "Is x = k - 1 always suitable?The answer is yes, as x! + (x - 1)! = (x - 1)! \\times (x + 1) = ((k - 1) - 1)! \\times ((k - 1) + 1) = (k - 2)! \\times (k), which is clearly a multiple of k.Therefore, x = k - 1 is the answer.Time complexity: \\mathcal{O}(1)", "id": "1768A", "url": "https://codeforces.com/contest/1768/problem/A"}
{"plan": "Note that every ordinary number can be represented as d \\cdot (10^0 + 10^1 + \\ldots + 10^k). Therefore, to count all ordinary numbers among the numbers from 1 to  n , it is enough to count the number of (d, k) pairs such that d \\cdot (10^0 + 10^1 + \\ldots + 10^k) \\le n. In the given constraints, it is enough to iterate over d from 1 to 9 and k from 0 to 8.", "id": "1520B", "url": "https://codeforces.com/contest/1520/problem/B"}
{"plan": "The problem is equivalent to finding the farthest cell from ( x , y ). It is easy to see that, if they move optimally, ( i , j ) can reach ( x , y ) just by moving in an L shape, and this is equivalent to the Manhattan distance between the two points. The longest distance a prisoner will move on rows is max( x - 1 , n - x ), and for the columns it is ( y - 1 , m - y ). So answer is just max( x - 1 , n - x ) + max( y - 1 , m - y )", "id": "1415A", "url": "https://codeforces.com/contest/1415/problem/A"}
{"plan": "Note that adding elements between positions i (1 \\le i \\le n - 1) and i + 1 will not change the ratio of the adjacent elements, except for the ones just added. Therefore, for each pair of adjacent numbers, the problem can be solved independently.Let us solve the problem for a adjacent pair of numbers a_i and a_{i+1} for which the inequality from the statements does not hold. Suppose that 2a_i \\le a_{i+1} (if not, we will swap them). Then between a_i and a_{i+1} it requires to insert \\left\\lceil log_2 \\left(\\frac{a_{i+1}}{a_i}\\right) - 1 \\right\\rceil elements of the form: It is better not to use explicit formula, but to use the following cycle: while a[i] * 2 < a[i + 1]:  a[i] *= 2  ans += 1", "id": "1490A", "url": "https://codeforces.com/contest/1490/problem/A"}
{"plan": "You had to to calculate the time that each elevator would need and compare them. Let the time required by the first elevator be d_1 = |a - 1|, and the time required by the second one be d_2 = |b - c| + |c - 1|. Then the answer is 1 if d_1 < d_2, 2 if d_1 > d_2 and 3 if d_1 = d_2", "id": "1729A", "url": "https://codeforces.com/contest/1729/problem/A"}
{"plan": "Let \\mathit{sum} — the initial sum in the array, \\mathit{cnt}_0 — the number of even numbers, \\mathit{cnt}_1 — the number of odd numbers.Let's see how these values ​​change with each action. In fact, we can consider four main options: Add an even number x to all even numbers. Then \\mathit{sum} will increase by x \\cdot \\mathit{cnt}_0, and the number of even and odd numbers will remain the same. Add an odd number x to all even numbers. Then \\mathit{sum} will increase by x \\cdot \\mathit{cnt}_0, the number of even numbers will become 0, all numbers will become odd, so \\mathit{cnt}_1 = n. Add an even number x to all odd numbers. Then \\mathit{sum} will increase by x \\cdot \\mathit{cnt}_1, and the number of even and odd numbers will remain the same. Add an odd number x to all odd numbers. Then \\mathit{sum} will increase by x \\cdot \\mathit{cnt}_1, the number of odd numbers will become 0, all numbers will become even, so \\mathit{cnt}_0 = n.", "id": "1744B", "url": "https://codeforces.com/contest/1744/problem/B"}
{"plan": "You need to implement what is written in the statement. You can either use an if-statement for each of the characters \\{\\texttt{c}, \\texttt{o}, \\texttt{d}, \\texttt{e}, \\texttt{f}, \\texttt{r}, \\texttt{s}\\}, or you can iterate through the string \\texttt{codeforces} check if the current character equals c.", "id": "1791A", "url": "https://codeforces.com/contest/1791/problem/A"}
{"plan": "We consider 2 cases. The first is that the starting and ending point lie on an axis-aligned line. In this case, we simply pull the box in 1 direction, and the time needed is the distance between the 2 points as we need 1 second to decrease the distance by 1.The second is that they do not lie on any axis-aligned line. Wabbit can pull the box horizontally (left or right depends on the relative values of x_1 and x_2) for |x_1-x_2| seconds, take 2 seconds to move either above or below the box, then take another |y_1-y_2| seconds to move the box to (x_2,y_2).", "id": "1428A", "url": "https://codeforces.com/contest/1428/problem/A"}
{"plan": "To solve the problem we need to find the character with the highest alphabetical order in our string, since Atilla will need at least that alphabet size and won't need more. To do this iterate through the string and find the character with the highest alphabetical order. Output the maximum alphabetical order found. The solution can be done in O(n).", "id": "1760B", "url": "https://codeforces.com/contest/1760/problem/B"}
{"plan": "If n is odd, let k=\\frac{n+1}{2} be the width of the last block. It is possible to create a square of side length k using every block as follows:  Line 1 contains a 1 \\times k block; Line 2 contains a 1 \\times 1 block and a 1 \\times (k-1) block; Line 3 contains a 1 \\times 2 block and a 1 \\times (k-2) block; \\ldots Line i contains a 1 \\times (i-1) block and a 1 \\times (k-i+1) block; \\ldots Line k contains a 1 \\times (k-1) block and a 1 \\times 1 block. Since the area of this square is k^2, and the n+1-th block has a width of k tiles, the total area of the first n+1 blocks is equal to k^2+k \\lt (k+1)^2. Therefore, the answer for n+1 is also k.In conclusion, the answer for each testcase is \\lfloor \\frac{n+1}{2} \\rfloor.Time complexity per testcase: O(1).", "id": "1748A", "url": "https://codeforces.com/contest/1748/problem/A"}
{"plan": "Do we really need to check all the subarrays?Consider a subarray (a_i, a_{i + 1}, \\ldots, a_{j}). If we add a new element a_{j + 1}, when will the new subarray (a_i, a_{i + 1}, \\ldots, a_{j}, a_{j + 1}) give a better result? Pause and think.The minimum of the new subarray can't get better(the minimum of a smaller subarray \\ge the minimum of a larger subarray). So only when a_{j + 1} is greater than the previous maximum, then it will give a better result. But in that case, do we really need to check the whole subarray to get that result? Can we get the same or a better result from a smaller subarray? Think.Here the maximum is a_{j + 1}. So if the minimum is not a_i, then the subarray (a_{i + 1}, a_{i + 2}, \\ldots, a_{j + 1}) will give the same result. Otherwise, the minimum of (a_{i + 1}, a_{i + 2}, \\ldots, a_{j + 1}) will not be smaller which implies that (a_{i + 1}, a_{i + 2}, \\ldots, a_{j + 1}) will give a better result!So if we add a new element, we don't have to check the whole subarray, checking (a_i, a_{i + 1}, \\ldots, a_{j}) and (a_{i + 1}, a_{i + 2}, \\ldots, a_{j + 1}) is enough.What good this observation just brought to this world? Think.Yes, we don't have to check subarrays with length > 2, because according to the observation, (a_1, a_2, a_3) won't give a better result than (a_1, a_2) and (a_2, a_3). And subarrays with length 4 won't give a better result than subarrays with length 3 and subarrays with length 3 won't give a better result than subarrays with length 2. You got the idea, right? Another thing to notice here is that the product of maximum and minimum of two integers is just the product of two integers. So the answer to the problem is the maximum of the products of adjacent elements in a.Time Complexity: \\mathcal{O}(n)", "id": "1554A", "url": "https://codeforces.com/contest/1554/problem/A"}
{"plan": "Notice that the answer depends only on the number of the reviewers of the third type who upvote the movie. Optimally we would want every single reviewer of the third type to upvote. We can achieve it with the following construction: send all reviewers of the first type to the first server, all reviewers of the second type to the second server and all reviewers of the third type to the first server. Since there are no downvotes on the first server, all reviewers of the third type will upvote.Thus, the answer is the total number of reviewers of the first and the third type.Overall complexity: O(n) per testcase.", "id": "1511A", "url": "https://codeforces.com/contest/1511/problem/A"}
{"plan": "There should be same number of 2 at a_1, a_2, \\cdots a_k and a_{k+1}, \\cdots, a_n.By checking every k, we can solve the problem at O(N^2). By sweeping k from 1 to n-1, we can solve the problem in O(N). Not counting the number of 2 but naively multiplying using sweeping in python was accepted since it has time complexity O(N^2).Checking every k and naively multiplying solutions are O(N^3), so those solutions won't fit in time limit.", "id": "1788A", "url": "https://codeforces.com/contest/1788/problem/A"}
{"plan": "This problem has a lot of solutions. You could even hard code all possible tests to solve it. But this problem has O(1) solution. Let the digit of x be dig. Then our character pressed each digit before dig exactly 10 times (1 + 2 + 3 + 4). And the amount of times he pressed the digit dig depends on the length of x. Let len be the length of x, then the amount of times he pressed the digit dig is 1 + 2 + \\ldots + len = \\frac{len(len + 1)}{2}. So the final answer is 10 \\cdot (dig - 1) + \\frac{len(len + 1)}{2}.", "id": "1433A", "url": "https://codeforces.com/contest/1433/problem/A"}
{"plan": "Replace even numbers with 0 and odd numbers with 1 in the array a. Now we observe that the given operation is equivalent to selecting two equal adjacent elements and deleting one of them. Now the array can be visualized as strips of zeros (in green) and ones (in red) like this [\\color{green}{0,0,0},\\color{red}{1,1,1,1},\\color{green}{0},\\color{red}{1,1}]. Note that since the number of adjacent elements (a[i],a[i+1]) such that a[i] \\ne a[i+1] remains constant (nice invariant!), every strip can be handled independently. The size of every strip must be 1 in the final array and performing an operation reduces the size of the corresponding strip by 1.So, for a strip of length L, it would require L-1 operations to reduce its size to 1. So, every strip would contribute -1 to the number of operations apart from its length. So, the answer is (n -  total no. of strips) which also equals (n - x - 1) where x is number of adjacent elements (a[i],a[i+1]) such that (a[i] \\ne a[i+1]).", "id": "1777A", "url": "https://codeforces.com/contest/1777/problem/A"}
{"plan": "Note, that after any of the operations, the parity of the expression a - b does not change, so if the initial difference of the pair c - d is odd, then it is impossible to get this pair. Now, note that if we can get a (c, d) pair, then it can be obtained in no more than 2 operations. To do this, consider three cases:  c = d = 0  — in this case answer is 0, because initial pair is (0, 0).  c = d  — in this case answer is 1. For this, it is enough for us to use the operation of the first type with k = c = d.  c \\neq d  — in this case answer is 2. For this we can use the operations of the first type with k = \\frac{c + d}{2}. After that, it is enough for us to use either an operation of the second type with k = c - \\frac{|c - d|}{2} if c > d, or an operation of the third type with k = d - \\frac{|c - d|}{2} otherwise.", "id": "1556A", "url": "https://codeforces.com/contest/1556/problem/A"}
{"plan": "step 1: Assume that a_{i} = 0 for each 1 \\le i \\le n, what should we do? Nothing! The array is already sorted and the answer is 0.step 2: After sorting the array, consider the first non-zero element of a, how many elements after that are equal to zero? In other words, consider smallest i such that a_{i} > 0, how many indices k exist such that i < k and Unable to parse markup [type=CF_MATHJAX]? 0, because we call an array a sorted (in non-decreasing order), if for all 1 \\le i < j \\le n, a_{i} \\le a_{j} holds. So all numbers after leftmost non-zero element must be non-zero too.step 3: assume that after sorting a, a_{i} (1 \\le i \\le n) is the leftmost non-zero element. Define G_{1} as the set of indices j such that 1 \\le j < i and a_{j} > 0 at the beginning, also define G_{2} as the set of indices j such that i \\le j \\le n and a_{j} = 0 at the beginning. What is the answer? max(|G_{1}|, |G_{2}|). It's obvious that in one operation at most one element will be deleted from each group. So we must perform at least max(|G_{1}|, |G_{2}|) operations.  Now we want to show that it's sufficient too. There are three cases:min(|G_{1}|, |G_{2}|) > 1, at this point, we know that all elements of a are 0 or 1. So we can pick one element from G_{1} and add it to an element from G_{2}, so the size of both groups will decrease by 1. It's obvious that all elements of a will remain less than or equal to 1 after this operation.|G_{1}| = 0, it's easy to see that we can add a[k] (k \\in G_{2}) to a random element. So |G_{2}| will decrease by 1.|G_{2}| = 0, it's easy to see that we can add a[k] (k \\in G_{1}) to the last element of a. So |G_{1}| will decrease by 1.step 4: taskNow how can we solve the problem using previous steps? solutionIf all elements are equal to 0, the answer is obviously zero. Otherwise we will calculate two arrays, number of ones in each prefix and number of zeros in each suffix. We will also fix the leftmost non-zero element and calculate the answer for it easily by using Step 3 algorithm in O(n).", "id": "1746B", "url": "https://codeforces.com/contest/1746/problem/B"}
{"plan": "Let n = (m + 1) \\cdot q + r.\nNote that you need to use a promotion if a \\cdot m \\leq b \\cdot (m + 1). In this case, we will buy potatoes q times for the promotion. The remaining potatoes (or all if the promotion is unprofitable) can be bought at \\min(a, b) per kilogram.\nThen the answer is:\n\nq \\cdot \\min(a \\cdot m, b \\cdot (m + 1)) + r \\cdot \\min(a, b)\nThus this solution works in \\mathcal{O}(1)\n\nCodet = int(input())", "id": "1793A", "url": "https://codeforces.com/contest/1793/problem/A"}
{"plan": "The answer is just \\min{(\\lceil {p \\over a} \\rceil \\cdot a, \\lceil {p \\over b} \\rceil \\cdot b, \\lceil {p \\over c} \\rceil \\cdot c)} - p.Complexity: O(1).", "id": "1492A", "url": "https://codeforces.com/contest/1492/problem/A"}
{"plan": "To solve the problem, you may convert the string to lower case, strip all duplicated characters from it and compare the result to \"meow\" string.To exclude duplicate characters, you can, for example, use the unique function in C++.", "id": "1800A", "url": "https://codeforces.com/contest/1800/problem/A"}
{"plan": "To make the arithmetic mean be equal to exactly 1 the sum needs to be equal to the number of elements in the array.Let's consider 3 cases for this problem:1) The sum of the array equals n: Here the answer is 0 since the arithmetic mean of the array is initially 1.2) The sum of the array is smaller than n: The answer is always 1 since we can add a single integer k such that sum + k = n + 1 is satisfied and more specifically k = n - sum + 1.3) The sum of the array is greater than n: If we add any number apart from 0 will add to the sum more or equal than to the number of elements. The number of 0's to add can be found by a loop of adding 0's until the number of elements is equal to the sum or by the simple formula of sum-n.", "id": "1537A", "url": "https://codeforces.com/contest/1537/problem/A"}
{"plan": "If we do our operation on two arbitrary integers x \\le y, it is always better to copy x into y rather than to copy y into x (since a resulting pair (x, x + y) is better than (y, x + y)). Now, let's assume that we do our operation on two integers x \\le y such that x is not the minimum element of our array. If we replace x with minimum, we can always achieve at least the same answer. Thus, we can take any index m such that a_m is the array minimum and use it to increase all other values.Time complexity: O(n) or O(nk) per testcase.Space complexity: O(n)", "id": "1417A", "url": "https://codeforces.com/contest/1417/problem/A"}
{"plan": "Obviously, you can always obtain the optimal answer without using west or south moves. So the shortest path consists of x east moves and y north moves. Let's estimate the lower bound of the answer. Take a look at these constructions: \"E?E?E?E?E\" and \"N?N?N?N?N\" (let question mark be any command different from the used one). That's the tightest you can put east or north moves in.So the answer is at least 2 \\cdot max(x, y) - 1. For x \\neq y you can put them just as in the construction and fill the rest of question marks with a stay in place move. x = y case works differently, though. You can do it only in x + y moves by taking alternating moves.Overall complexity: O(1) per testcase.", "id": "1452A", "url": "https://codeforces.com/contest/1452/problem/A"}
{"plan": "To find the cell number in a different numbering, you can find (r, c) coordinates of the cell with the number x in the numbering \"by columns\":   r = ((x-1) \\mod r) + 1, where a \\mod b is the remainder of dividing the number a by the number b;  c = \\left\\lceil \\frac{x}{n} \\right\\rceil, where \\left\\lceil \\frac{a}{b} \\right\\rceil is the division of the number a to the number b rounded up. Then, the cell number in numbering \"by lines\" will be equal to (r-1)*m + c.", "id": "1506A", "url": "https://codeforces.com/contest/1506/problem/A"}
{"plan": "We can notice that the answer is the number of zeros between the leftmost occurrence of 1 and the rightmost occurrence of 1. Why is it true? Let's take the leftmost maximum by inclusion segment of 1 and just shift it right. We can see that using this algorithm we will do exactly described amount of moves and there is no way improve the answer.", "id": "1433B", "url": "https://codeforces.com/contest/1433/problem/B"}
{"plan": "If n \\le 2 then the answer is 1. Otherwise, you can \"remove\" the first floor and then the answer is \\left\\lfloor\\frac{n - 3}{x}\\right\\rfloor + 2.", "id": "1426A", "url": "https://codeforces.com/contest/1426/problem/A"}
{"plan": "We are assuming initial sum is odd. Suppose f(x)(1 \\leq x \\leq 10^6) gives the minimum number of operations needed to change parity of x.Iterate from i=1 to n and calculate f(a_i) for each i.Answer is minimum among all the calculated values.Time complexity is O(n \\cdot log(A_{max})).", "id": "1762A", "url": "https://codeforces.com/contest/1762/problem/A"}
{"plan": "step 1:It's obvious that the answer is \"NO\" if a_{i} = 0 for all 1 \\le i \\le n.step 2:Lets prove that the answer is \"YES\" if a_{i} = 1 for at least one 1 \\le i \\le n.step 3:If size of a is equal to k, just use second type operation once and we are done.step 4:Otherwise (if |a| > k), there will be three cases: (assume that a_{j} = 1)  if j > 2, you can use first type operation on first and second element and decrease size of a by 1. else if j < |a|-1, you can use first type operation on last and second to last element and decrease size of a by 1. else, it can be shown easily that |a| = 3 and k = 2 so you can use second type operation twice and turn a into a single 1. In first and second case, you can continue decreasing size of a until |a| = k (or you reach 3-rd case) and you can use second type operation to reach your aim.step 5:So we proved that the answer is \"YES\" iff a_{i} = 1 for at least one 1 \\le i \\le n or in other words, iff \\sum_{i = 1}^n a_{i} > 0.", "id": "1746A", "url": "https://codeforces.com/contest/1746/problem/A"}
{"plan": "Note that on the i-th step, Alice takes i cards from the deck. It means that after k steps, \\frac{k(k + 1)}{2} steps are taken from the deck. Thus, after O(\\sqrt{n}) steps, the deck is empty. We can simulate the steps one by one by taking care of whose turn it is and what is the color of the top card. Using this information, we can keep track of how many cards of what color each player has. Print this information in the end.", "id": "1786A2", "url": "https://codeforces.com/contest/1786/problem/A2"}
{"plan": "If for some hero i, no other hero is weaker than i, then the i-th hero cannot win any fights and is not a possible winner. Otherwise, the hero i is a possible winner — he may fight the weakest hero 100^{500} times and be declared the winner.So the solution to the problem is calculating the number of minimum elements in the array a, since all other elements denote possible winners of the tournament.", "id": "1487A", "url": "https://codeforces.com/contest/1487/problem/A"}
{"plan": "The simplest solution — go through the problem, because of which the teacher might have suspicions. Now you can find the first day when Polycarp solved this problem and the last such day. Between these two days, all problems should be the same. If this is not the case, the answer is \"NO\".", "id": "1520A", "url": "https://codeforces.com/contest/1520/problem/A"}
{"plan": "For positions which numbers are the same, they cannot be colored using same color.Let us color the i-th occurrence of any number using color i.We can see that:   We cannot use fewer colors: if there are k occurrence of any number, at least k color is needed.  The assignment of color is valid: Since the sequence was non-increasing, for any subsequence it is also non-increasing. As there are no duplicates in colored subsequence, the subsequence is strictly increasing as well. Therefore, we only need to count the number of occurrence of every number and take the maximum of them.Time complexity: O(n) per test case", "id": "1478A", "url": "https://codeforces.com/contest/1478/problem/A"}
{"plan": "The idea is as follows: we will go from the end of the string t and get the original string s.Note that if the current digit is 0, then a letter with a two-digit number has been encoded. Then we take a substring of length three from the end, discard 0 and get the number of the original letter.Otherwise, the current number \\neq 0, then a letter with a one-digit number was encoded. We easily reconstruct the original letter.Next, discard the already processed characters and repeat the process until the encoded string is complete.", "id": "1729B", "url": "https://codeforces.com/contest/1729/problem/B"}
{"plan": "It's enough to sort a in non-decreasing order and sort b in non-increasing order and check, whether a_i + b_i \\leq x for all i.Correctness can be proven by induction: let's show that if answer exists, there is a solution with minimum in a and maximum in b are paired. Let m_a be minimum in a and m_b be maximum in b. Let p be number paired with m_a and q be number paired with m_b. Since solution is correct, m_a + p \\leq x and m_b + q \\leq x. Since m_a \\leq q, m_a + m_b \\leq x. Since p \\leq m_b, p + q \\leq x. So, m_a can be paired with m_b.", "id": "1445A", "url": "https://codeforces.com/contest/1445/problem/A"}
{"plan": "We can keep track of our current point (x,y) as we iterate over the string:   if s_i = \\texttt{L}, then decrement x (set x \\leftarrow x-1);  if s_i = \\texttt{R}, then increment x (set x \\leftarrow x+1);  if s_i = \\texttt{U}, then increment y (set y \\leftarrow y+1);  if s_i = \\texttt{D}, then decrement y (set y \\leftarrow y-1).  Initially, set x=y=0. If x=y=1 is ever true, then we should output YES; otherwise, we output NO.The time complexity is \\mathcal{O}(n).", "id": "1791B", "url": "https://codeforces.com/contest/1791/problem/B"}
{"plan": "Let's note that if a_i = a_j, then s_i must be equal to s_j, since we must change the same value to the same letter. If we check this for all pairs of i and j and find no such contradictions, then the answer is \"YES\", otherwise \"NO\".We got the solution for O(n^2) for one test case.", "id": "1744A", "url": "https://codeforces.com/contest/1744/problem/A"}
{"plan": "Suppose the values of a_1, a_2, a_3, a_4 are sorted in non-descending order. Then the shorter side of the rectangle cannot be longer than a_1, because one of the sides must be formed by a segment of length a_1. Similarly, the longer side of the rectangle cannot be longer than a_3, because there should be at least two segments with length not less than the length of the longer side. So, the answer cannot be greater than a_1 \\cdot a_3.It's easy to construct the rectangle with exactly this area by drawing the following segments:  from (0, 0) to (a_1, 0);  from (0, a_3) to (a_2, a_3);  from (0, 0) to (0, a_3);  from (a_1, 0) to (a_1, a_4). So, the solution is to sort the sequence [a_1, a_2, a_3, a_4], and then print a_1 \\cdot a_3.", "id": "1468E", "url": "https://codeforces.com/contest/1468/problem/E"}
{"plan": "Here are two ways to implement what's given in the problem:  Take input as an array [a_1, a_2, a_3], and sort it. Output the middle element.  Write two if-statements. The first: if (a>b \\text{ and } a<c) \\text{ or } (a<b \\text{ and } a>c), output a. Else, if (b>a \\text{ and } b<c) \\text{ or } (b<a \\text{ and } b>c), output b. Else, output c.", "id": "1760A", "url": "https://codeforces.com/contest/1760/problem/A"}
{"plan": "Note, that posts will be removed in the order n, n - 1, \\ldots, 1.The post n - k + 1 will be removed at the first time, when there are at least k different numbers among p_1, p_2, \\ldots, p_i.So let's calculate the number of different numbers among p_1, p_2, \\ldots, p_i for each i using boolean array of length m iterating i from 1 to m. Using them we can calculate the answer.Time complexity: O(n + m).", "id": "1799A", "url": "https://codeforces.com/contest/1799/problem/A"}
{"plan": "There are some solutions based on case analysis, but in my opinion, the most elegant one is the following:Let's pick a color with the maximum possible number of pixels and repaint all other pixels into it. We will try to pick all pixels of some other color and repaint them in one operation, and we can ignore the constraint that we can repaint no more than 2 pixels, since we will never need to repaint 3 or 4 pixels in one operation. So, the number of operations is just the number of colors other than the one we chosen, or just d - 1, where d is the number of different colors in the image. To calculate this, we can use a set or an array of size 26, where we mark which colors are present.", "id": "1721A", "url": "https://codeforces.com/contest/1721/problem/A"}
{"plan": "Therefore, for the input n, we can simply check which one of n, n+1, and n+2 has its gcd-sum > 1, and print the lowest of them.", "id": "1498A", "url": "https://codeforces.com/contest/1498/problem/A"}
{"plan": "Note that it is enough to consider the string full = YesYes...Yes, where Yes is written 18 times, since 18 \\cdot 3 = 54, and our substring s has size |s| \\le 50.Then we just use the built-in function find to find out if our string s is a substring of the string full.", "id": "1759A", "url": "https://codeforces.com/contest/1759/problem/A"}
{"plan": "Hint 1: You can think of this problem as 2 independent 1D questions (one is up and down , and the other is left and right) instead of 1 2D question.Hint 2: For each 1D part what is the interval of positions that you can reach and see if the end point is in this interval.Hint 3: The interval of up and down is [-The count of D , The count of U] and the interval of left and right is [-The count of L , The count of R].", "id": "1481A", "url": "https://codeforces.com/contest/1481/problem/A"}
{"plan": "This is a simple implementation problem. Let's calculate two values for each i from 1 to n: cnt_i — the number of occurrences of i in a and idx_i — any position of i in a.Then, let's iterate through i from 1 to n and, if cnt_i = 1, just print idx_i (because if it is the only such element then we found the winner). If we didn't find any such element, we have to print -1.", "id": "1454B", "url": "https://codeforces.com/contest/1454/problem/B"}
{"plan": "Suppose the first skill to be performed is fixed. Then it is optimal to use the following greedy strategy.   If possible, perform a skill of a different type from the last skill. If there are multiple skills of a different type from the last skill, choose the one with the largest initial damage. Inspired by the above observation, if the type of the first skill is fixed, it is optimal to choose the one with the smallest initial damage. This is because the first skill will be never doubled. Therefore, we have the following algorithm.   Try each possible type a (of the first skill).  Remove the skill of type a with the smallest intial damage.  Alternate the types of the following skills as much as possible. This algorithm is sufficient to pass this problem. Nevertheless, a slightly more elegant analysis will give a simpler solution.   If the number of skills of type fire is equal to that of skills of type frost, double the damage of all skills except for the one with the smallest initial damage.  Otherwise, let k be the smaller number of skills of either type, then double the damage of the largest k skills of both types. The time complexity is O(n \\log n) due to sortings.", "id": "1738A", "url": "https://codeforces.com/contest/1738/problem/A"}
{"plan": "The key insight is that due to the fact that there is only one row of enemy pawns, and those pawns never move, there are only 3 possible columns where one of Gregor's pawns can end up in.We can solve this problem greedily, going from column 1 to column N. At the current column j, if Gregor has a pawn in this column, then we greedily consider 3 cases.   If there is an uncaptured enemy pawn in column j-1, mark that pawn as captured and increment the answer. Column j-1 will never be looked at again, so this decision is optimal. If there is no pawn in column j, just move Gregor's pawn forward, and increment the answer. If there is an uncaptured enemy pawn in column j+1, mark that pawn as captured and increment the answer. Otherwise, this pawn will not reach the first row. This greedy solution is guaranteed to produce the maximum possible answer.The time complexity is \\mathcal{O}(N).", "id": "1549B", "url": "https://codeforces.com/contest/1549/problem/B"}
{"plan": "Let's perform the process in reverse: we will remove the first and last character of the string, if these two characters are different. We should do this as long as possible, since we need to find the shortest initial string. So the algorithm is straightfoward: keep track of the left and right characters, and if they are different, remove both. Otherwise, output the length of the current string (or output 0 if the string became empty).There are a few ways to implement this. For example, you can keep two pointers, one at the beginning of the string and one at the end, say, l=1 and r=n, and check if s_l=s_r. If it's true, then we increment l and decrement r. Otherwise, we output r-l+1. We stop when l \\geq r.Alternatively, you can use deque to simulate the operations directly. The time complexity is \\mathcal{O}(n).", "id": "1791C", "url": "https://codeforces.com/contest/1791/problem/C"}
{"plan": "The described sorting algorithm is similar to Odd-even sort.In this problem, it's enough to carefully implement the process described in the problem statement. Here is one sample implementation in C++:#include <bits/stdc++.h>using namespace std;int main() {  int tt;  cin >> tt;  while (tt–) {    int n;    cin >> n;    vector<int> a(n);    for (int i = 0; i < n; i++) {      cin >> a[i];    }    int ans = 0;    while (!is_sorted(a.begin(), a.end())) {      for (int i = ans % 2; i + 1 < n; i += 2) {        if (a[i] > a[i + 1]) {          swap(a[i], a[i + 1]);        }      }      ans += 1;    }    cout << ans << endl;  }  return 0;}To estimate the complexity of this solution, we need to know the maximum number of iterations required to sort a permutation of length n. It turns out that this number is equal to exactly n, thus the complexity of the algorithm is O(n^2). This is intuitive because the algorithm looks similar to bubble sort that requires n iterations too, or you can directly check that sorting [n, n-1, \\ldots, 1] requires n iterations and reason that \"more sorted\" sequences can't require more iterations than \"less sorted\" sequences, and [n, n-1, \\ldots, 1] is naturally the \"least sorted\" sequence of them all. For a formal proof see e.g. the linked Wikipedia page. The proof also follows from the editorial of problem F in Div. 1. If you have a simpler proof, please share in comments!", "id": "1561A", "url": "https://codeforces.com/contest/1561/problem/A"}
{"plan": "Without loss of generality, let's say r \\le b (otherwise, we can swap them). Note that you can't use more than r packets (at least one red bean in each packet), so b can't exceed r \\cdot (d + 1) (at most d + 1 blue beans in each packet).So, if b > r \\cdot (d + 1) then asnwer is NO. Otherwise, we can form exactly r packets.", "id": "1519A", "url": "https://codeforces.com/contest/1519/problem/A"}
{"plan": "Notice that it's never optimal to erase a subsequence of length greater than 2 because every RBS of length above 2 contains an RBS of length 2 inside and removing it won't break the regular property of the outside one.So the task can be solved for the round and the square brackets independently, the answer will be the sum of both. Let's solve the version for brackets '(' and ')'. In general, you just want to remove consecutive substring \"()\" until there is no more left in the string. That can be done by processing the string from left and right and maintaining a stack of current brackets. If the top bracket in it is '(' and the current bracket is ')', then you can increment the answer and remove that bracket from the stack. Otherwise, you push the current bracket to the stack.Overall complexity: O(|s|) per testcase.", "id": "1452C", "url": "https://codeforces.com/contest/1452/problem/C"}
{"plan": "You only need to write an if statement and check if any of these are true: a+b=c, b+c=a, c+a=b.", "id": "1742A", "url": "https://codeforces.com/contest/1742/problem/A"}
{"plan": "Note that bending the cable on the wall is not necessary: we can always bend it on the floor and on the ceiling, while keeping the vertical part of the cable straight. Thus, we can just disregard the height of the room, view the problem as two-dimensional, and add h to the answer at the end.In the two-dimensional formulation, we need to connect points (a, b) and (f, g) with a cable that goes parallel to the coordinate axes and touches at least one side of the (0, 0) — (w, d) rectangle. We can now casework on the side of the rectangle (the sides are referred to as in the picture from the problem statement):   If the cable touches the front side, its length will be b + |a - f| + g.  If the cable touches the left side, its length will be a + |b - g| + f.  If the cable touches the back side, its length will be (d - b) + |a - f| + (d - g).  If the cable touches the right side, its length will be (w - a) + |b - g| + (w - f). Out of these four values, the smallest one (plus h) is the answer.", "id": "1782A", "url": "https://codeforces.com/contest/1782/problem/A"}
{"plan": "There are many ways to solve this problem.The most naive one (iterating through all numbers from 1 to n in each test case and checking if they are extremely round) fails, since it is O(tn), but you can optimize it by noticing that extremely round numbers are rare. So, for example, we can iterate through all numbers from 1 to 999999 once, remember which ones are extremely round, store them into an array, and while answering the test case, only check the numbers from the array we have created.There is also a solution in O(1) per test case with a formula, try to invent it yourself.", "id": "1766A", "url": "https://codeforces.com/contest/1766/problem/A"}
{"plan": "Let's say we've chosen index i. What will happen?   If the values of a_i and a_{i+1} have opposite signs, flipping them won't change the initial sum.  if a_i = a_{i+1} = 1, flipping them will reduce the sum by 4.  if a_i = a_{i+1} = -1, flipping them will increase the sum by 4. So, for each i < n, we can check the values of a_i and a_{i+1}, and we can measure the effects on the sum based on the three cases stated above. Among the effects, take the one that maximizes the sum.Time complexity: In each test case, \\mathcal{O}(n)", "id": "1778A", "url": "https://codeforces.com/contest/1778/problem/A"}
{"plan": "Considering that if we want to find the max value of x \\cdot y, then the whole string is the best to calculate, for it 0 s and 1 s are the max.Then considering x \\cdot x and y \\cdot y : what we need to do is to calculate the max continuous number of 0 or 1, compare its square to the first condition, then take the bigger one as the answer.", "id": "1750B", "url": "https://codeforces.com/contest/1750/problem/B"}
{"plan": "If s is palindromic initially, we can operate on the interval [1,n], the answer is Yes.Let's consider the other case. In a palindrome s, for each i in [1,\\lfloor n/2\\rfloor], s_{i}=s_{n-i+1} must hold. For those i, we may check whether s_{i}=s_{n-i+1} is true in the initial string. For all the illegal positions i, the operation must contain either i or n+1-i, but not both. For the legal positions, the operation must contain neither of i nor n+1-i, or both of them.If the illegal positions is continuous (which means that they are l,l+1,\\dots,r-1,r for some l and r), we may operate on the interval [l,r] (or [n+1-r,n+1-l]), making the string palindromic. The answer is Yes.Otherwise, there must be some legal positions that lie between the illegal ones. Suppose the illegal positions range between [l,r] (but not continuous), and the operation is [o_{1},o_{2}]. Without loss of generality, let the operation lies in the left part of the string. Then o_{1}\\le l,r\\le o_{2}<n+1-r must hold to correct all the illegal positions. This interval covers all the legal positions that lie between the illegal ones but does not cover their symmetrical positions. Thus, such kind of operation will produce new illegal positions. In other words, there are no valid operations in this situation. The answer is No.Time complexity: O(n).", "id": "1789B", "url": "https://codeforces.com/contest/1789/problem/B"}
{"plan": "A greedy strategy always works: take k + 1 largest barrels, choose one barrel among them and pour all water from those barrels to the chosen barrel. That way, we make the minimum amount equal to 0 (it's quite obvious that we can't do anything better here), and the maximum amount as large as possible, so the difference between them will be as large as possible.", "id": "1430B", "url": "https://codeforces.com/contest/1430/problem/B"}
{"plan": "If a+b+2\\leq n, we can always find such pair, here is a possible construction: The red part is their longest common prefix, and the blue part is their longest common suffix.Otherwise, the two permutations must be equal, so such pair exists iff a=b=n.", "id": "1761A", "url": "https://codeforces.com/contest/1761/problem/A"}
{"plan": "The answer is 'yes' if and only if there are exactly n odd numbers.", "id": "1542A", "url": "https://codeforces.com/contest/1542/problem/A"}
{"plan": "Notice that evolution will go on for no more than n iterations, since on each iteration at least one new living cell will appear, and if it doesn't this would mean that we remain in the same state as on the previous step and the simulation is over. Knowing this we can write a simple simulation of the process described in the problem statement, which would process each iteration in O(n).Final complexity: O(n^2).", "id": "1523A", "url": "https://codeforces.com/contest/1523/problem/A"}
{"plan": "Let S denotes sum of element of array a. Claim: Answer is |S|.Proof: Let sum of all positive elements is S_{pos} and sum of all negative elements S_{neg}. Put all positive numbers in first group and negative numbers in second group. We get ||S_{pos}| - |S_{neg}|| = |S|.Let's prove that we can not do better than that. Let S_1 denotes sum of elements of first group and S_2 denotes sum of elements of second group. We have |S_1| - |S_2| \\leq |S_1 + S_2| = |S|. Hence |S| is the upperbound for the answer.", "id": "1747A", "url": "https://codeforces.com/contest/1747/problem/A"}
{"plan": "It's not hard to see that if l \\le \\lfloor \\frac{r}{2} \\rfloor + 1, then r \\bmod (\\lfloor \\frac{r}{2} \\rfloor + 1) = \\lfloor \\frac{r-1}{2} \\rfloor. It can be shown that the maximal possible answer.At the same time, let the segment not contain number \\lfloor \\frac{r}{2} \\rfloor + 1, that is, l > \\lfloor \\frac{r}{2} \\rfloor + 1. Then we can show that the maximal answer is r \\bmod l = r-l.Asymptotics: O(1) per test case.", "id": "1562A", "url": "https://codeforces.com/contest/1562/problem/A"}
{"plan": "Let T =  n & (n-1) & (n-2) & (n-3) & ... (k)If there is at least one integer from K to N whose bit at the i_{th} index is 0, then the value of the i_{th} bit in T will also be 0. We can easily observe that the msb (Highest set bit in n) in N will become 0 for the first time when K = 2^{msb}- 1. All the other bits will become zero when K = 2^{msb}. Thus the answer is, K = 2^{msb} - 1.", "id": "1527A", "url": "https://codeforces.com/contest/1527/problem/A"}
{"plan": "There are two possible solutions for the problem.The first solution is basically brute force. Each password can be obtained from an integer from 0 to 9999. If the number is from 1000 to 9999, then it's already a password of length 4. Otherwise, you have to prepend it with enough zeros so that it becomes length 4.Then you have to check if the password is valid. First, check if it consists of exactly two different digits: make a set of all its characters (set<char> in case of C++, for example) and check its size. Then check if the first digit of the password appears exactly twice. It would mean that the other digits appears exactly twice as well. Finally, check if neither of the found digits are forbidden.The second solution is based on combinatorics. First, choose the two digits that will appear in the password: C(10 - n, 2). Since n digits are prohibited, the remaining 10 - n are allowed. Second, choose the positions that will be taken by the first one: C(4, 2). The answer is the product of these two values.", "id": "1743A", "url": "https://codeforces.com/contest/1743/problem/A"}
{"plan": "Check if the string has length 5 and if it has the characters \\texttt{T}, \\texttt{i}, \\texttt{m}, \\texttt{u}, \\texttt{r}. The complexity is \\mathcal{O}(n). You can also sort the string, and check if it is \\texttt{Timur} when sorted (which is \\texttt{Timru}).", "id": "1722A", "url": "https://codeforces.com/contest/1722/problem/A"}
{"plan": "The line we draw must go through a triangle's vertex; otherwise, two sides of the triangle are split, and one of the resulting parts becomes a quadrilateral.So we need to check if it is possible to make a horizontal or vertical cut through a vertex. A horizontal cut is possible if all y-coordinates are different (we can draw it through a vertex with the median y-coordinate); a vertical cut is possible if all x-coordinates are different (we can draw it through a vertex with the median x-coordinate).So, all we need to check is the following pair of conditions:  all x_i are different;  all y_i are different.", "id": "1767A", "url": "https://codeforces.com/contest/1767/problem/A"}
{"plan": "The solution is to iterate over all possible triangles, find their areas, and compute how many of these areas are distinct. So the problem is to calculate the area of a given triangle efficiently. There are many possible ways to do it; I will describe the most straightforward method.Recall the formula for the triangle's area: As we want to count distinct areas we can forget about dividing by 2 and focus on calculating base \\cdot height. Note that all triangles are of form (x_1, 0), (x_2, 0) and (0, 1). Thanks to this, if we pick a side (x_1, 0), (x_2, 0) as a base, then the height is equal to 1! As a result, base \\cdot height = |x_1 - x_2|. Final complexity is \\mathcal{O}(n^2) per test case.", "id": "1466A", "url": "https://codeforces.com/contest/1466/problem/A"}
{"plan": "Sure, you can just implement the rotation operation and check all 4 possible ways to rotate the matrix, but it's kinda boring. The model solution does the different thing.If a matrix is beautiful, then its minimum is in the upper left corner, and its maximum is in the lower right corner (and vice versa). If you rotate it, the element from the upper left corner goes to the upper right corner, and the element from the lower right corner goes to the lower left corner — so these elements are still in the opposite corners. No matter how many times we rotate a beautiful matrix, its minimum and maximum elements will be in the opposite corners — and the opposite is true as well; if you have a 2 \\times 2 matrix with minimum and maximum elements in opposite corners, it can be rotated in such a way that it becomes beautiful.So, all we need to check is that the minimum and the maximum elements are in the opposite corners. There are many ways to do it; in my opinion, the most elegant one is to read all four elements in an array of size 4; then the opposite corners of the matrix correspond either to positions 0 and 3, or to positions 1 and 2 in this array. So, we check that the sum of positions of minimum and maximum is exactly 3.", "id": "1772B", "url": "https://codeforces.com/contest/1772/problem/B"}
{"plan": "The solution of this task is to basically implement what was written in the statement.Let dep_i be the moment of train departure from the station i (dep_0 = 0 initially). Then train arrives at the current station i at moment ar_i = dep_{i - 1} + (a_i - b_{i - 1}) + tm_i and departure at moment dep_i = \\max(b_i, ar_i + \\frac{b_i - a_i + 1}{2}).The answer is ar_n.", "id": "1501A", "url": "https://codeforces.com/contest/1501/problem/A"}
{"plan": "First we can observe that if a card has r_i = b_i, then if doesn't affect the comparison between R and B regardless of its position. We can forget about all such cards. Formally, if we erase all such cards after the permutation, then R and B are still compared in the same way, and further all the remaining cards are still permuted equiprobably.Now we only have cards with r_i > b_i (let's call them Red-favourable) and r_i < b_i (call them Blue-favourable). But then, the comparison between R and B will only be decided by whether the first card is Red- or Blue-favourable. Naturally, if, say, there are more Red-favourable cards than Blue-favourable cards, then Red is more likely to win. If there is an equal number of Red- and Blue-favourable cards, then the chances are equal.Thus, for the solution purposes we only need to count indices i with r_i > b_i and those with r_i < b_i, and compare these two numbers.", "id": "1459A", "url": "https://codeforces.com/contest/1459/problem/A"}
{"plan": "Noticing the hint above we now deduce x = a & b where & is bitwise AND. So just printing (a \\oplus (a & b)) + (b \\oplus (a & b)) works, but there's an even nicer formula. We'll leave it up to you to prove that (a \\oplus (a & b)) + (b \\oplus (a & b)) = a \\oplus b, where \\oplus is the bitwise XOR :)", "id": "1421A", "url": "https://codeforces.com/contest/1421/problem/A"}
{"plan": "The first solution: Fix the position of the numbers a_n, b_n. And for each other index i, let's check whether the conditions a_i \\leq a_n and b_i \\leq b_n are met. If not, swap a_i and b_i and check again. If the conditions are not met for some index in both variants — the answer is \"No\", otherwise \"Yes\".The second solution: Let M be the maximum of all the numbers a_1, a_2, \\ldots, a_n, b_1, b_2, \\ldots, b_n. Then if a_n < M and b_n < M the answer is — \"No\", since in the one of the arrays where the number M appears after the operations, the maximum will be M, which is greater than a_n and b_n. Otherwise, either a_n = M or b_n = M. If a_n = M, then swap a_n and b_n, now b_n = M. So the condition b_n = \\max(b_1, b_2, \\ldots, b_n) will always be met, regardless of the numbers b_1, b_2, \\ldots, b_{n-1}. Therefore, it would be best to put in b_i the maximum of the numbers a_i, b_i for each i. After that, it remains to check the condition for the array a_1, a_2, \\ldots, a_n, and if it is met, the answer is —\"Yes\", otherwise —\"No\"", "id": "1798A", "url": "https://codeforces.com/contest/1798/problem/A"}
{"plan": "We can prove that if we have k_1 + k_2 white cells on the board then we can place any w white dominoes as long as 2w \\le k_1 + k_2.The proof is the following: if k_1 \\ge k_2 let's place one domino at position ((1, k_1 - 1), (1, k_1)), otherwise let's place domino at position ((2, k_2 - 1), (2, k_2)). Then we can solve the placement of w - 1 dominoes in k_1 - 2 cells in the first row and k_2 cells of the second row recursively (or, analogically, k_1 and k_2 - 2).At the end, either all dominoes are placed or k_1 < 2 and k_2 < 2. If k_1 = 0 or k_2 = 0 then, since 2w \\le k_1 + k_2, then w = 0 or we successfully placed all dominoes. If k_1 = 1 and k_2 = 1 then we, possibly, need to place one domino more — and we can place it vertically.We can prove that we can place any b dominoes as long as 2b \\le (n - k_1) + (n - k_2) in the same manner.As a result, all we need to check is that 2w \\le k_1 + k_2 and 2b \\le (n - k_1) + (n - k_2).", "id": "1499A", "url": "https://codeforces.com/contest/1499/problem/A"}
{"plan": "Let sa, sb are the last characters of lines a and b respectively. And |a|, |b| are the sizes of these strings.  sa \\neq sb: then the answer depends only on sa and sb and is uniquely defined as the inverse of sa to sb (\"<\" if sa > sb, \">\" if sa < sb, since the characters S, M, L are in reverse order in the alphabet).  sa = sb:   |a| = |b|. Then the answer is \"=\". This also covers the case sa = sb = M;  sa = sb =S. Then the larger the size of the string, the smaller the size of the t-shirt. That is, the answer is \"<\" if |a| > |b| and \">\" if |a| < |b|;  sa = sb =L. Then the larger the size of the string, the smaller the size of the t-shirt. That is, the answer is \"<\" if |a| < |b| and \">\" if |a| > |b|;", "id": "1741A", "url": "https://codeforces.com/contest/1741/problem/A"}
{"plan": "We will consider each character seperately. Look at the i-th character; if it is originally a 1, we can either change it to a 0 and pay h + c_0 coins for this specific character, or we can not change it and pay c_1 coins for it. Since we want to pay as little as possible, we take the minimum of these two. So if the ith character is a 1, we will have to pay min(c_1, h + c_0) coins for it. A similar logic can be used for the zeroes; if the ith character is a 0 we will have to pay min(c_0, h + c_1) coins. So we iterate over s, and for each character we add the required minimum to the sum, depending on whether it's a 0 or 1.Time complexity: O(n)", "id": "1440A", "url": "https://codeforces.com/contest/1440/problem/A"}
{"plan": "The solution is simple: let's create an integer variable (initially set to 0) that will contain the number of considered liked integers. Let's iterate over all positive integers starting with 1. Let's increase the variable only when the considered number is liked. If the variable is equal to k, let's stop the iteration and output the last considered number.Since the answer for k = 1000 is x = 1666, the count of considered numbers is at most 1666 so the solution will work on the specified limitations fast enough.", "id": "1560A", "url": "https://codeforces.com/contest/1560/problem/A"}
{"plan": "Since you need e liters of essence to be exactly k\\ \\% of potion then we can write an equality: \\frac{e}{e + w} = \\frac{k}{100} or k = x \\cdot e and 100 = x \\cdot (e + w) for some integer x. Since we need to minimize e + w and x(e + w) = 100, then we should maximize x, but both k and 100 should be divisible by x. In other words, taking x as Greatest Common Divisor of k and 100 is optimal.As a result e + w = \\frac{100}{x} = \\frac{100}{\\gcd(k, 100)}.", "id": "1525A", "url": "https://codeforces.com/contest/1525/problem/A"}
{"plan": "Let's fix the number of people going to the cinema k and try to choose a set of this exact size. What happens to people with different a_i?  If a_i < k, person i definitely wants to go.  If a_i > k, person i definitely does not want to go.  If a_i = k, there is actually no good outcome for person i. If person i goes to the cinema, there are only k - 1 other people going, so person i will be sad (since k - 1 < a_i). If person i does not go, there are k other people going, so person i will be sad too (since k \\ge a_i). Thus, for a set of size k to exist, there must be no people with a_i = k, and the number of people with a_i < k must be exactly k. We can easily check these conditions if we use an auxiliary array cnt such that cnt[x] is equal to the number of people with a_i = x.Alternative solution:Notice that if a set of k people can go to the cinema, it must always be a set of people with the smallest a_i. Thus, we can start with sorting the array a in non-decreasing order.Then, for each length k of a prefix of this array, we can check whether the first k elements are all smaller than k, and the remaining n-k elements are all greater than k.However, since the array is sorted, it is enough to check that the k-th element is smaller than k, and the k+1-th element is greater than k.", "id": "1781A", "url": "https://codeforces.com/contest/1781/problem/A"}
